---
title: 10. 类（ES6）
sidebar_position: 10
date: 2022-07-26
tags: [JavaScript]
---

## 1 Class 类

class Person 相当于 `function Person()`，是一个 function Person 的语法糖。

### 1.1 类的结构

包含：构造函数 (类名)、构造器 `constructor`、实例方法、获取函数 `get`、设置函数 `set`、静态方法 `static`。

```js
// 构造函数
class Person {
    // 构造器
    constructor(name, age){
        this.name = name;
        this.age = age;
        this.nickname_ = "none";
    }
    // 实例方法：在类的原型对象上定义
    callName(){
        console.log(this.name)
    }
    // 静态方法：在类（构造函数）上定义
    static callHello() {
        console.log("Hello")
    }
    // get 函数：在类的原型对象上定义
    get nickname() {
        return this.nickname_;
    }
    // set 函数：在类的原型对象上定义
    set nickname(newName) {
        if(newName !== this.nickname_) {
            this.nickname_ = newName;
        } else {
            console.log("Cannot duplicate the original nickname")
        }      
    }
    
    // 在constructor外设置属性，和在 constructor 内一样，会赋值到实例化对象中，不论是 属性 还是 方法。
		//	- 通过属性名的方式定义的方法，就会绑定到实例化对象上，而不是在原型上。
    perName = "Happy";
	  callPerName = function() {  // 函数表达式
		    console.log(this.perName)
    };
}

// 测试：
// 类的实例化：
let p = new Person("Moxy", 18)
// 实例方法
p.callName()	 	  // Moxy
// 静态方法
Person.callHello()	  // Hello
// get 函数
p.nickname = "Ninjee" // 'Ninjee'
// set 函数
p.nickname;			  // 'Ninjee'
// 实例化属性 + 方法
p1.perName			  // 'Happy'
p1.callPerName()	  // Happy
// typeof 
typeof Person 		// function，class Person 实际上是一个函数
```

**注意：**

- 在 constructor 外定义方法：最后会在 `Person.prototype` 类的原型上定义，是公有方法；
- 在 constructor 外定义属性：最后会在 "类的实例化对象" 上定义，是实例化属性的私有方法；
  - 定义属性也可以赋值为一个方法（函数表达式），这样就拥有一个实例化方法了；
  - **这其实和在 constructor 中定义是一模一样的。**



##### 1.1.1 类的实例化

```js
let p = new Person()
```

使用 `new` 调用 class ，会执行如下操作：

1. 创建一个 **新对象** `{}`；
2. 为新对象绑定 **原型链**：`{}.__proto__ = Person.prototype`；
3. 将 class 的作用域 **`this`** 赋给新对象 `{}`；
4. 执行 class 中的代码，为 `{}` 添加属性： `constructor.call(this, params...);`
   - 在 constructor 外的、没有 `get`，`set`，`static` 标识符的属性，全部定义到 `{}` 中。
5. 如果构造函数最终会返回一个对象，就返回 **构造函数中的对象**。
6. 如果构造函数没有返回其他对象，就会返回 **新对象**。

最终，代码中左侧的 `p` 变量接收到了新创建的那个对象。



#### 1.1.2 static 静态方法

静态方法，会把这个方法添加到 `class` 构造函数自身（类名上），而不是其 `.prototype` 原型链上。所以实例化对象无法使用这个函数，而是通过 类名直接调用。

```js
class Foo{
    constructor(){}
    static callHello(){
        console.log("Hello")
    }
}

Foo.callHello() // Hello

let f = new Foo()
f.callHello()	// f.callHello is not a function
```

static 的一种常见用法，可以随机实例化对象，下面就是随机化生成 Person 实例化的例子：

```js
class Person {
  constructor(name, age){
    this.name = name;
    this.age = age;
    this.nickname_ = "none";
  }

  callName(){
    console.log(this.name)
  }
  
  static randomPerson() {
    const names = ["Jack", "Marry", "Bob", "Jobs", "Happy", "Moon", "Ted"];
		const nameIndex = Math.floor(Math.random() * names.length);
		const name = names[nameIndex];
    const age = Math.floor(Math.random() * 30);
    return new Person(name, age);
	}
}

for (let i = 0; i < 10; i++)
  console.log(Person.randomPerson());
// Person {name: 'Ted', age: 21, nickname_: 'none'}
// Person {name: 'Moon', age: 15, nickname_: 'none'}
// Person {name: 'Marry', age: 6, nickname_: 'none'}
// Person {name: 'Ted', age: 14, nickname_: 'none'}
// Person {name: 'Ted', age: 26, nickname_: 'none'}
// Person {name: 'Happy', age: 20, nickname_: 'none'}
// Person {name: 'Bob', age: 22, nickname_: 'none'}
// Person {name: 'Jack', age: 5, nickname_: 'none'}
// Person {name: 'Ted', age: 20, nickname_: 'none'}
// Person {name: 'Happy', age: 3, nickname_: 'none'}
```



#### 1.1.3 可迭代的类

可以在类中定义 generator，也可以直接把类改为一个可迭代对象。

```js
class Person {
    constructor() {
        this.nicknames = ["Moxy", "Ninjee", "walnut"];
    }

    *[Symbol.iterator]() {
        yield* this.nicknames.entries();
    }
}

let p = new Person()
for (let [idx, v] of p) {
    console.log(`id: ${idx}, nickName: ${v}`)
}
// id: 0, nickName: Moxy
// id: 1, nickName: Ninjee
// id: 2, nickName: walnut
```

或者直接返回一个 iterator 实例。

```js
class Person {
    constructor() {
        this.nicknames = ["Moxy", "Ninjee", "walnut"];
    }

    [Symbol.iterator]() {
        return this.nicknames.entries(); // entries会返回一个iterator
    }
}

let p = new Person()
for (let [idx, v] of p) {
    console.log(`id: ${idx}, nickName: ${v}`)
}
// id: 0, nickName: Moxy
// id: 1, nickName: Ninjee
// id: 2, nickName: walnut
```



#### 1.1.4 备注：

类方法是不可枚举的，对象的方法是默认可枚举的。



与 `function Foo` 相比，`class Foo` 的特点是：

- 不提升。`function Foo` 存在变量提升，而 `class` 类不存在变量提升。
- 无法直接调用。`class Foo` 无法直接调用，必须 `new` 实例化有才可以调用。而 `function Foo` 的可以当作一个普通函数那样使用： `Foo.call(obj)` 



### 1.2 extends 继承

- `extends` 继承，是一个语法糖，用来在两个函数原型之间建立 `[[Prototype]]` 链接。
- `static` ，子类也继承了父类的 static 静态方法，可以直接 `Son.fatherStaticMethod` 调用。
- `super` 自动指向父构造器，也就是指向父对象。
- `super` 有两种用法：
  - `super` 指向父构造器 constructor，主要是为了实现父类属性的继承；
  - `super` 指向父对象 class，主要是为了让子类可以在自定义方法中调用父类方法。



用法一：`super` 实现继承

```js
class Foo {
    constructor(a, b) {
        this.x = a;
        this.y = b;
    }
    gimmeXY() {
        return this.x * this.y;
    }
}

class Bar extends Foo {
    constructor(a, b, c) {
        super(a, b);
        this.z = c;
    }
    gimmeXYZ() {
        return super.gimmeXY() * this.z;
    }
}

let b = new Bar(5, 15, 25);
b.x;            // 5
b.y;            // 15
b.z;            // 25
b.gimmeXYZ()    // 1875

Foo.prototype === Bar.prototype.__proto__	// true
```

- `class Bar extends Foo` 表示把 `Bar.prototype` 的 `[[Prototype]]` 指向了 `Foo.prototype`。
- `super` 是静态绑定的。
- 子类构造器 `constructor` 中，必须先使用 `super`，才能使用 `this`。
- 如果在继承父类后，没有定义 `constructor`，则引擎会默认帮你调一次 `constructor`，并在其中也调用一次 `super`，传递所有值给 `super`，像下面这样：

```js
// 默认的 constructor
constructor(...args){
    super(...args);
}
```



用法二：`super` 子类调用父类方法

下例中，子类重载了父类的 func 方法，使用 super，子类的 func 方法先执行了父类原方法，再额外新增逻辑：

```js
class Father {
	func() {
		console.log('逻辑1');
    console.log('逻辑2');
    console.log('逻辑3');
  }
  
  static StaticMethod() {
   	console.log('Father StaticMethod');
	}
  
  static FatherStaticMethod() {
   	console.log('Father FatherStaticMethod');
	}
}

class Son extends Father {
  constructor(){
    super();
  }
  
  // 重写父类方法
  func() {
    super.func();  // 复用父类方法
		console.log('新增：逻辑4');
    console.log('新增：逻辑5');
	}
  
  // 重写父类静态方法
  static StaticMethod() {
    super.StaticMethod() // 复用父类静态方法，⚠️这里静态方法的调用采用 super.，而不是类名 Father.
   	console.log('son static method');
	}
}

const s = new Son();

// 父类方法的复用和重载
s.func() 
	// 逻辑1
	// 逻辑2
	// 逻辑3
	// 新增：逻辑4
	// 新增：逻辑5


// 父类静态方法的复用和重载
Son.StaticMethod()
	// Father StaticMethod
	// son static method


// 父类静态方法的继承
Son.FatherStaticMethod()
	// Father FatherStaticMethod
```



#### 1.2.1 new.target

`new.target` 是一个元属性（meta property），它总是指向 new 实际上直接调用的构造器。

```js
class Foo {
    constructor() {
        console.log("Foo:", new.target.name)
    }
}

class Bar extends Foo {
    constructor() {
        super()
        console.log("Bar:", new.target.name)
    }
    baz() {
        console.log("baz:", new.target)
    }
}
let a = new Bar()
// Foo: Bar
// Bar: Bar
a.baz()
// baz: undefined
```

可以看到，即使在子类中通过 `super` 去调用父类构造器，`new.target` 也会正确的指向子类构造器： `new`  调用的是谁 (`Bar`)，`new.target` 就永远指向谁的构造器  (`Bar` 的 `constructor`)。

如果 `new.target` 值为 `undefined` ，则表明这个函数不是通过 `new` 来调用的。



#### 1.2.2 抽象基类（接口）

是一个接口，它可以供其他类继承，但本身不会被实例化。可以通过 `new.target` 来实现。

通过在实例化时，检测 `new.target`，判断该类是否为一个抽象类，然后阻止可能的实例化动作。

```js
// 接口
class Vehicle {
    constructor() {
        console.log(new.target.name);
        if (new.target === Vehicle) 
            throw new Error('Vehicle cannot be derectly instantiated')
    }
}
// 派生类（子类）
class Bus extends Vehicle {}

// 实例化测试
new Vehicle()	// Vehicle
							// Uncaught Error: Vehicle cannot be derectly instantiated
new Bus()	 // Bus
```



### 1.3 使用 Bebel 转化

> 🔗链接：
>
> [Babel 官网](https://babeljs.io)
>
> [Babel 代码转化测试](https://babeljs.io/repl)
>
> - Targets：not ie 10 让浏览器支持 ie 10 以上版本（ES6以下）



让一个函数只能通过 `new` 调用：

```js
// es6 语法：
Person {}

// bebel 转化的 es5语法：
function _classCallCheck(instance, Constructor) { 
  if (!(instance instanceof Constructor)) {  // 判断 instance 实例原型链上是否有 Constructor
    throw new TypeError("Cannot call a class as a function"); 
  } 
}

var Person = /*#__PURE__*/(function() {
  function Person() {
  // 如果是 new 调用，this是一个新创建的对象，其原型链指向了Person
  _classCallCheck(this, Person);
  }
  return Person;
})();

// test
new Person()  // Person {}
Person()			// Uncaught TypeError: Cannot call a class as a function
```

- 使用 `var Person = (function() {}) ... `
  - 这里使用一个立即执行函数，隔绝了外部作用域，使内部变量的名称不会泄露到外部。
  - `/*#__PURE__#*/` 表明了这个立即执行函数是一个 **纯函数**，这可以让 webpack 在打包时的 tree shaking 环节时判断，如果这个函数没有实际使用过，则会删掉这个纯函数，从而减小打包体积。



实现 class Person：

```js
// 🏠 es6 源代码
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  eating() {
    console.log(this.name + " eating~")
  }
}

// 🔥 babel 转换
"use strict";

// 判断是否用 new 调用，如果不是则抛出错误
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// 遍历所有的属性，然后设置每个属性的特性enumerable, configurable, writable
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

// 给构造函数添加方法（公有方法+静态方法）
function _createClass(Constructor, protoProps, staticProps) {
	// 定义构造函数的原型对象上的方法
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  // 定义构造函数上的静态方法（如果有）
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}


var Person = /*#__PURE__*/ (function () {
  // 构造函数
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }
	// 原型对象上添加方法 + 构造函数上添加静态方法
  _createClass(Person, [
    {
      key: "eating",
      value: function eating() {
        console.log(this.name + " eating~");
      }
    }
  ]);

  return Person;
})();
```





## 2 Module 模块

即 ES Module。其包含的两个关键词`export` 和 `import `均只能用在最顶层的作用域中。



### 2.1 export 导出

`export` 关键字放在声明的前面。

- `default export` 导出的是这些变量 / 函数的地址（类似指针），而不是它们的值。所以，在一个函数 / 变量被导出后，这个函数 / 变量的结构或值发生了改变，外部也会得到对应的更新。

- `export` 导出的是变量名称（标识符），也就是说当这个变量指向了新的函数，就会导出新的函数。

特点：

1. **不支持双向绑定**，也就是说，不支持对一个导入的模块进行修改，只能读取和使用。
2. 在模块内没有全局作用域。在模块内是一个模块的作用域。
3. 模块内没有用 `export` 标识的变量 / 函数都在莫块作用域内部保持私有，被标识的则会被导出。

#### 1 命名导出

命名导出：导出变量 / 函数时，把标识符名称导出：

```js
// 方式一
export function foo() {...}
export let arr = [1,2,3]
export let a = 42

// 方式二
function foo() {...}
let arr = [1, 2, 3]
let a = 42
export {foo, arr, a}
```

导出时可以重命名：

```js
function foo() {...}
export {foo as bar}
```



#### 2 默认导出

默认导出，把一个特定导出，绑定设置为导入模块时的默认导出。绑定的名称就是 `default`。

- **每个模块定义只能有一个 `default`  默认导出。**

- **只有 `export default` 导出的是具体函数地址，其余 export 都是导出标识符。**

```js
// 情况一: 导出的是具体函数
function foo() {...}
export default foo
                
// 情况二: 导出的是具体函数
export default function foo() {...}

// 情况三: 导出的是foo标识符
function foo() {...}
export { foo as default }
```

`export default ..` 接收一个表达式，导出的是这个表达式返回地址值。

情况一 和 情况二：默认导出的是 `foo` 绑定的那个表达式地址，而不是标识符 `foo`。这意味着如果后续代码把 `foo` 修改引用了其他函数 / 变量，默认导出的依然是最初的那个函数。

- 情况一和情况二，是两种不同的表达方式，通常会使用更简洁的情况二。

情况三：默认导出的是标识符 `foo`，也就是说，后续如果把 `foo` 标识符引用别的函数 / 变量，导出的值也就跟着发生改变，



#### 3 连续导出

连续导出，当从一个模块导入一些函数 / 变量后，可以选择再次将它们导出：

```js
export {foo, bar} from "baz";
export {foo as f, bar as b} from "baz";
export * from "baz";
```



### 2.2 import 导入

导入一个模块 API 的某个特定成员到当前模块的顶层作用域中。

```js
import {foo, bar, baz} from "foo";

// 支持重命名
import {foo as f} from "foo";

// 只有一个导入模块时，省略括号
import foo from "foo";

// 把foo.js 默认导出 和 命名导出 的成员，全部一起导入：
import defaultFoo, {bar, baz as b} from "foo";
// defaultFoo 就是默认导出的成员，此为对这个成员进行命名
```



**命名空间导入 namespace import**

```js
import * as foo from "foo"

// 该方式必须用通配符，不可以像下面这样只导入一部分：
import {bar,baz} as foo from "foo"
```

这段代码的意思是：

1. 把 `foo.js` 文件中，导出的成员全部导入到当前模块中；
2. 把这些成员全部绑定到 `foo` 对象名下。

如果全部导入中，有默认成员，则这个默认成员的名称就是 `default`。比如上例中，该模块中导入的默认成员名称为 `foo.default`。

所有导入的成员是只读的，不可修改，否则会报错：`TypeError!`



































