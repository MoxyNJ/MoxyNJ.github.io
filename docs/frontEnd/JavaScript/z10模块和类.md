---
title: 10. 类（ES6）
sidebar_position: 10
date: 2022-07-26
tags: [JavaScript]
---

## 1 Class 类

### 1.1 类的结构

包含：构造函数 (类名)、构造器 `constructor`、实例方法、获取函数 `get`、设置函数 `set`、静态方法 `static`。

```js
// 构造函数
class Person {
    // 构造器
    constructor(name, age){
        this.name = name;
        this.age = age;
        this.nickname_ = "none";
    }
    // 实例方法：在原型上定义
    callName(){
        console.log(this.name)
    }
    // 静态方法：在类（构造函数）上定义
    static callHello() {
        console.log("Hello")
    }
    // get 函数
    get nickname() {
        return this.nickname_;
    }
    // set 函数
    set nickname(newName) {
        if(newName !== this.nickname_) {
            this.nickname_ = newName;
        } else {
            console.log("Cannot duplicate the original nickname")
        }      
    }
    
    // 如果在这里设置属性，则会赋值到实例化对象中，不论是 属性 还是 方法。
    // 通过属性名的方式定义的方法，就会绑定到实例化对象上，而不是在原型上。
    perName = "Happy"
	  callPerName = function() {
		    console.log(this.perName)
    }
}

// 测试：
// 类的实例化：
let p = new Person("Moxy", 18)
// 实例方法
p.callName()	 	  // Moxy
// 静态方法
Person.callHello()	  // Hello
// get 函数
p.nickname = "Ninjee" // 'Ninjee'
// set 函数
p.nickname;			  // 'Ninjee'
// 实例化属性 + 方法
p1.perName			  // 'Happy'
p1.callPerName()	  // Happy
```

**注意：**

- 在 constructor 外定义方法：最后会在 `Person.prototype` 类的原型上定义，是公有方法；
- 在 constructor 外定义属性：最后会在 "类的实例化对象" 上定义，是实例化属性的私有方法；
  - 定义属性也可以赋值为一个方法（函数表达式），这样就拥有一个实例化方法了；
  - **这其实和在 constructor 中定义是一模一样的。**





##### 1.1.1 类的实例化

```js
let p = new Person()
```

使用 `new` 调用类的构造函数，会执行如下操作：

1. 创建一个 **新对象** `{}`；
2. 为新对象绑定 **原型链**：`{}.__proto__ = Person.prototype`；
3. 将构造函数的作用域 **`this`** 赋给新对象 `{}`；
4. 执行构造函数中的代码，为 `{}` 添加属性：`Person.call(this)`；
5. 如果构造函数最终会返回一个对象，就返回 **构造函数中的对象**。
6. 如果构造函数没有返回其他对象，就会返回 **新对象**。

最终，代码中左侧的 `p` 变量接收到了新创建的那个对象。



#### 1.1.2 static 静态方法

静态方法，会把这个方法添加到 `class` 构造函数自身（类名上），而不是其 `.prototype` 原型链上。所以实例化对象无法使用这个函数，而是通过 类名直接调用。

```js
class Foo{
    constructor(){}
    static callHello(){
        console.log("Hello")
    }
}

Foo.callHello() // Hello

let f = new Foo()
f.callHello()	// f.callHello is not a function
```



##### 1.1.3 可迭代的类

可以在类中定义 generator，也可以直接把类改为一个可迭代对象。

```js
class Person {
    constructor() {
        this.nicknames = ["Moxy", "Ninjee", "walnut"];
    }

    *[Symbol.iterator]() {
        yield* this.nicknames.entries();
    }
}

let p = new Person()
for (let [idx, v] of p) {
    console.log(`id: ${idx}, nickName: ${v}`)
}
// id: 0, nickName: Moxy
// id: 1, nickName: Ninjee
// id: 2, nickName: walnut
```

或者直接返回一个 iterator 实例。

```js
class Person {
    constructor() {
        this.nicknames = ["Moxy", "Ninjee", "walnut"];
    }

    [Symbol.iterator]() {
        return this.nicknames.entries(); // entries会返回一个iterator
    }
}

let p = new Person()
for (let [idx, v] of p) {
    console.log(`id: ${idx}, nickName: ${v}`)
}
// id: 0, nickName: Moxy
// id: 1, nickName: Ninjee
// id: 2, nickName: walnut
```



##### 1.1.4 备注：

类方法是不可枚举的，对象的方法是默认可枚举的。



与 `function Foo` 相比，`class Foo` 的特点是：

- 不提升。`function Foo` 存在变量提升，而 `class` 类不存在变量提升。
- 无法直接调用。`class Foo` 无法直接调用，必须 `new` 实例化有才可以调用。而 `function Foo` 的可以当作一个普通函数那样使用： `Foo.call(obj)` 



### 1.2 extends 继承

- `extends` 继承，是一个语法糖，用来在两个函数原型之间建立 `[[Prototype]]` 链接。

- `super` 自动指向父构造器，也就是指向父对象。

```js
class Foo {
    constructor(a, b) {
        this.x = a;
        this.y = b;
    }
    gimmeXY() {
        return this.x * this.y;
    }
}

class Bar extends Foo {
    constructor(a, b, c) {
        super(a, b);
        this.z = c;
    }
    gimmeXYZ() {
        return super.gimmeXY() * this.z;
    }
}

let b = new Bar(5, 15, 25);
b.x;            // 5
b.y;            // 15
b.z;            // 25
b.gimmeXYZ()    // 1875

Foo.prototype === Bar.prototype.__proto__	// true
```

- `class Bar extends Foo` 表示把 `Bar.prototype` 的 `[[Prototype]]` 指向了 `Foo.prototype`。
- `super` 是静态绑定的。
- 子类构造器 `constructor` 中，必须先使用 `super`，才能使用 `this`。
- 如果在继承父类后，没有定义 `constructor`，则引擎会默认帮你调一次 `constructor`，并在其中也调用一次 `super`，传递所有值给 `super`，像下面这样：

```js
// 默认的 constructor
constructor(...args){
    super(...args);
}
```



#### 1.2.1 new.target

`new.target` 是一个元属性（meta property），它总是指向 new 实际上直接调用的构造器。

```js
class Foo {
    constructor() {
        console.log("Foo:", new.target.name)
    }
}

class Bar extends Foo {
    constructor() {
        super()
        console.log("Bar:", new.target.name)
    }
    baz() {
        console.log("baz:", new.target)
    }
}
let a = new Bar()
// Foo: Bar
// Bar: Bar
a.baz()
// baz: undefined
```

可以看到，即使在子类中通过 `super` 去调用父类构造器，`new.target` 也会正确的指向子类构造器： `new`  调用的是谁 (`Bar`)，`new.target` 就永远指向谁的构造器  (`Bar` 的 `constructor`)。

如果 `new.target` 值为 `undefined` ，则表明这个函数不是通过 `new` 来调用的。



#### 1.2.2 抽象基类

是一个接口，它可以供其他类继承，但本身不会被实例化。可以通过 `new.target` 来实现。

通过在实例化时，检测 `new.target`，判断该类是否为一个抽象类，然后阻止可能的实例化动作。

```js
// 接口
class Vehicle {
    constructor() {
        console.log(new.target.name);
        if (new.target === Vehicle) {
            throw new Error('Vehicle cannot be derectly instantiated')
        } else if
    }
}
// 派生类
class Bus extends Vehicle {}

// 实例化测试
new Vehicle()	// Vehicle
				// Uncaught Error: Vehicle cannot be derectly instantiated
new Bus()		// Bus
```



## 2 Module 模块

即 ES Module。其包含的两个关键词`export` 和 `import `均只能用在最顶层的作用域中。



### 2.1 export 导出

`export` 关键字放在声明的前面。

- `default export` 导出的是这些变量 / 函数的地址（类似指针），而不是它们的值。所以，在一个函数 / 变量被导出后，这个函数 / 变量的结构或值发生了改变，外部也会得到对应的更新。

- `export` 导出的是变量名称（标识符），也就是说当这个变量指向了新的函数，就会导出新的函数。

特点：

1. **不支持双向绑定**，也就是说，不支持对一个导入的模块进行修改，只能读取和使用。
2. 在模块内没有全局作用域。在模块内是一个模块的作用域。
3. 模块内没有用 `export` 标识的变量 / 函数都在莫块作用域内部保持私有，被标识的则会被导出。

#### 1 命名导出

命名导出：导出变量 / 函数时，把标识符名称导出：

```js
// 方式一
export function foo() {...}
export let arr = [1,2,3]
export let a = 42

// 方式二
function foo() {...}
let arr = [1, 2, 3]
let a = 42
export {foo, arr, a}
```

导出时可以重命名：

```js
function foo() {...}
export {foo as bar}
```



#### 2 默认导出

默认导出，把一个特定导出，绑定设置为导入模块时的默认导出。绑定的名称就是 `default`。

- **每个模块定义只能有一个 `default`  默认导出。**

- **只有 `export default` 导出的是具体函数地址，其余 export 都是导出标识符。**

```js
// 情况一: 导出的是具体函数
function foo() {...}
export default foo
                
// 情况二: 导出的是具体函数
export default function foo() {...}

// 情况三: 导出的是foo标识符
function foo() {...}
export { foo as default }
```

`export default ..` 接收一个表达式，导出的是这个表达式返回地址值。

情况一 和 情况二：默认导出的是 `foo` 绑定的那个表达式地址，而不是标识符 `foo`。这意味着如果后续代码把 `foo` 修改引用了其他函数 / 变量，默认导出的依然是最初的那个函数。

- 情况一和情况二，是两种不同的表达方式，通常会使用更简洁的情况二。

情况三：默认导出的是标识符 `foo`，也就是说，后续如果把 `foo` 标识符引用别的函数 / 变量，导出的值也就跟着发生改变，



#### 3 连续导出

连续导出，当从一个模块导入一些函数 / 变量后，可以选择再次将它们导出：

```js
export {foo, bar} from "baz";
export {foo as f, bar as b} from "baz";
export * from "baz";
```



### 2.2 import 导入

导入一个模块 API 的某个特定成员到当前模块的顶层作用域中。

```js
import {foo, bar, baz} from "foo";

// 支持重命名
import {foo as f} from "foo";

// 只有一个导入模块时，省略括号
import foo from "foo";

// 把foo.js 默认导出 和 命名导出 的成员，全部一起导入：
import defaultFoo, {bar, baz as b} from "foo";
// defaultFoo 就是默认导出的成员，此为对这个成员进行命名
```



**命名空间导入 namespace import**

```js
import * as foo from "foo"

// 该方式必须用通配符，不可以像下面这样只导入一部分：
import {bar,baz} as foo from "foo"
```

这段代码的意思是：

1. 把 `foo.js` 文件中，导出的成员全部导入到当前模块中；
2. 把这些成员全部绑定到 `foo` 对象名下。

如果全部导入中，有默认成员，则这个默认成员的名称就是 `default`。比如上例中，该模块中导入的默认成员名称为 `foo.default`。

所有导入的成员是只读的，不可修改，否则会报错：`TypeError!`



































