---
title: 浏览器相关
sidebar_position: 1
date: 2022-08-08
keywords:
  - 面试题
  - 面经
---

## 浏览器相关

### 问题：同源策略

#### 同源策略

同源请求、跨域请求。

同源策略（Same origin policy），它是由Netscape网景公司提出的一个著名的安全策略，浏览器都遵守该策略。

- **同源**： 协议、域名、端口号必须完全相同

- **跨域**： 违背同源策略就是跨域，浏览器会 **丢弃** 非同源的响应数据。


**通过 `window.origin` 或 `location.origin` 得到当前源。**

```js
http://moxy.com/index.html
http://moxy.com/server.php
//同源

http://a.wang.com
http://wang.com
//不同源，域名必须一模一样
```

也就是说，服务端有返回数据，浏览器也接收到了响应数据，但浏览器发现我们请求的是一个非同源的数据，浏览器再将其响应报文丢弃掉。

同源策略又分为以下两种：

1. DOM 同源策略：禁止对不同源的页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。
2. XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。无需再浏览器收到请求后拦截非同源数据，通过 XHR 发送的不同源请求可直接被拦截。



#### 跨域

当用户在 A 域中访问服务器获取资源，服务器会正常的返回资源。而当用户试图在其他域的网站去访问 A 域的资源，出于安全原因，服务器就会拒绝这种访问方式。

- 浏览器发送请求时，会把本地域放在请求头中发送给服务器，以便服务器对齐对其进行验证。

**可以跨域使用`CSS`、`JS`和图片**

- 同源策略限制的是数据访问，我们引用 `CSS`、`JS` 和图片等资源不限制。

**同源策略会让三种行为受限：**

- Cookie、LocalStorage 和 IndexDB 访问受限；
- 无法操作跨域 DOM（常见于 iframe）；
- Javascript 发起的 XHR 和 Fetch 请求受限；



#### 为什么跨域限制：

**如果没有 DOM 同源策略，也就是说不同域的 iframe 之间可以相互访问，那么黑客可以这样进行攻击：**

1. 做一个假网站，里面用 iframe 嵌套一个银行网站 `http://mybank.com`。
2. 把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。
3. 这时如果用户输入账号密码，我们的主网站可以跨域访问到 `http://mybank.com` 的 dom 节点，就可以拿到用户的账户密码了。

**如果没有 XMLHttpRequest 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击：**

1. 用户登录了自己的银行页面 `http://mybank.com`，`http://mybank.com` 向用户的 cookie 中添加用户标识。
2. 用户浏览了恶意页面 `http://evil.com`，执行了页面中的恶意 AJAX 请求代码。
3. `http://evil.com` 向 `http://mybank.com` 发起 AJAX HTTP 请求，请求会默认把 `http://mybank.com` 对应 cookie 也同时发送过去。
4. 银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据。此时数据就泄露了。
5. 而且由于 Ajax 在后台执行，用户无法感知这一过程。

> https://juejin.cn/post/6844903681683357710



#### 解决跨域问题：

解决跨域问题有两种方式：民间的 JSONP + 官方的 CORS（跨域资源共享）。



### 问题：什么是 JSONP

JSONP是 JSON with Padding 的略称，JSONP 是程序员提出的一种跨域解决方案。

- 在网页有一些标签天生具有跨域能力，比如：`img`、 `link`、 `iframe`、 `script`。这些标签发出的请求不会

JSONP 通过创建 `script` 标签，利用 src 属性进行跨域，来发送请求。**仅支持 get 请求**。

缺点：

1. **代码结构改变**，接受到响应数据后的处理代码，要全部放在回调函数中。
2. **控制反转**。调用回调函数，处理返回数据和后续逻辑的契机不在浏览器的js代码中，而是交给了服务器。
3. **后端协商**，需要和后端进行协商，确保服务器会正确调用回调函数，并携带正确的格式。JSONP 不易进行错误检查。





### 问题：什么是 CORS

CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方案。CORS 需要浏览器和服务器同时支持，**支持 get 和 post 请求。**

- 允许浏览器向跨源服务器，发出 `XMLHttpRequest` 请求，从而克服了 `AJAX` 只能同源使用的限制。

- 服务器的响应请求中设置：`"Access-Control-Allow-Origin" = *`

  实现 `CORS` 通信需要浏览器和服务器都支持。

CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息：

- 通过设置一个响应头来告诉浏览器，该请求允许跨域，而浏览器会对头部信息匹配，如果匹配成功则正常返回信息，浏览器收到该响应以后就会对响应放行，而不会拦截。



**注意：CORS 不支持`IE8/9`，**如果要在`IE8/9`使用`CORS`跨域需要使用`XDomainRequest`对象来支持`CORS`。



**浏览器 CORS**

浏览器会限制 **从脚本内发起** 的跨域 HTTP 请求。 例如 XHR 和 Fetch 就遵循同源策略。这意味着使用 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源。

Web 程序发出跨域请求后，浏览器会 **自动** 向我们的 HTTP header 添加一个额外的请求头字段：`Origin`。`Origin` 标记了请求的站点来源：

```http
GET https://api.website.com/users HTTP/1/1
Origin: https://www.mywebsite.com           // <- 浏览器自己加的
```

 服务器返回的 response 也会添加一些响应头字段，这些字段将 **显式表明** 此服务器是否允许这个跨域请求。



**客户端 CORS**

服务器开发人员，通过验证 `Origin` 是否允许跨域访问，然后在 HTTP 响应中添加额外的响应头字段 `Access-Control-*` 来表明是否允许跨域请求。

```js
all.get("/testAJAX" , function (req , res) {
	//通过res设置响应头，允许跨域请求
	//res.set("Access-Control-Allow-Origin","http://127.0.0.1:3000");
	res.set("Access-Control-Allow-Origin","*");
	res.send("testAJAX 返回的响应");
});
```



### 问题：DOM 0、DOM 2 事件模型的区别

DOM 0 级：绑定事件使用属性形式：`on + 事件名`。如 onclick、onmousemove、onmouseover。

- 如果对同一个元素绑定相同的事件，后边的会覆盖掉前边的。并且 DOM0 级事件只 **触发冒泡**，不能触发事件捕获阶段 。



DOM 2 级：绑定事件使用函数形式： `addEeventListener()`；删除事件使用 `removeEeventListener()`。

- DOM 2 级允许对同一个元素绑定多个相同的事件，后面的 **不会覆盖** 前面的。
  使用 addEventListener 方法为一个元素绑定事件时，它 **默认冒泡阶段触发**。如果第三个参数为 **true**，在捕获阶段也能触发。

注意：使用 DOM 0 和 DOM 2 同时添加事件模型，两者是不冲突的。



### 问题：判断两个 dom 节点是否相同

- **使用 === 来比较两个元素**。
- `A.isSameNode(B)`：是同一个节点时返回 true。DOM 4 被废弃。
- `isEqualNode()`：检查两个节点是否相等，不一定相同。

```html
<ul id="list">
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>

<script>
  const lis = [...document.getElementsByTagName('li')];
  const ul = document.getElementById('list');

  // 点击哪个li，就会输出它的下标。
  ul.addEventListener('click',function(e) {
    if(e.target.tagName === 'LI') {
      const i = lis.findIndex(item => item === e.target);  // 使用严格相等比较。
      console.log(i);
    }
  }) 
</script>
```



```js
● Array.prototype是数组，所以Array.isArray(Array.prototype)返回true
● for(i=1;i++<10;){} 执行完后i是多少？ 11
● console.log('a' + (2 > 1) ? 'some' : 'other')的值是多少？
  ○ 值是 'some'
  ○ +的优先级比？高
```

