<!doctype html>
<html lang="zh" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-interview/summary/操作系统">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.18">
<link rel="alternate" type="application/rss+xml" href="/rss.xml" title="ninjee RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="ninjee Atom Feed">
<link rel="alternate" type="application/json" href="/feed.json" title="ninjee JSON Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Ninjee的前端篮子" href="/opensearch.xml">
<script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0930342e569f854bebdeb485c0eac7f8",e.defer=!0;var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>
<meta name="baidu-site-verification" content="code-rqLUw5reVS">
<link rel="icon" href="/img/ninjee.jpeg">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="rgb(51 139 255)"><title data-rh="true">操作系统 - Ninjee的前端篮子</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://ninjee.netlify.app/img/ninjee.jpeg"><meta data-rh="true" name="twitter:image" content="https://ninjee.netlify.app/img/ninjee.jpeg"><meta data-rh="true" property="og:url" content="https://ninjee.netlify.app/docs/interview/summary/操作系统"><meta data-rh="true" name="docusaurus_locale" content="zh"><meta data-rh="true" name="docsearch:language" content="zh"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="操作系统 - Ninjee的前端篮子"><meta data-rh="true" name="description" content="第一章：绪论"><meta data-rh="true" property="og:description" content="第一章：绪论"><meta data-rh="true" name="keywords" content="操作系统"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ninjee.netlify.app/docs/interview/summary/操作系统"><link data-rh="true" rel="alternate" href="https://ninjee.netlify.app/docs/interview/summary/操作系统" hreflang="zh"><link data-rh="true" rel="alternate" href="https://ninjee.netlify.app/docs/interview/summary/操作系统" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://OITUMQ5615-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.7d792d30.css">
<link rel="preload" href="/assets/js/runtime~main.cbc0f3f2.js" as="script">
<link rel="preload" href="/assets/js/main.34499d57.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/ninjee-icon.png" alt="ninjee" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/ninjee-icon.png" alt="ninjee" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Ninjee</b></a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">前端知识</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/frontEnd/JavaScript">JavaScript</a></li><li><a class="dropdown__link" href="/docs/frontEnd/HTML&amp;CSS">HTML &amp; CSS</a></li><li><a class="dropdown__link" href="/docs/frontEnd/React">React</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">敲代码</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/code/algorithm">算法</a></li><li><a class="dropdown__link" href="/docs/code/writtenJs">手写Js</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">面试</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/interview/summary">总结</a></li><li><a class="dropdown__link" href="/docs/interview/iot">物联网</a></li></ul></div><a class="navbar__item navbar__link" href="/project">我的项目</a><div class="toggle_S7eR colorModeToggle_vKtC"><button class="clean-btn toggleButton_rCf9 toggleButtonDisabled_Pu9x" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v35p"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_nQuB"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_qEbK"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="docPage_P2Lg"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_RiAD"><nav class="menu thin-scrollbar menu_izAj"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/interview/summary">总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/interview/summary/浏览器相关">浏览器相关</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/interview/summary/计算机网络">计算机网络</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/interview/summary/操作系统">操作系统</a></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_FykI"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_DTRl"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Xlws" aria-label="breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/">🏠</a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="item name">操作系统</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>操作系统</h1></header><h2 class="anchor anchorWithStickyNavbar_mojV" id="第一章绪论">第一章：绪论<a class="hash-link" href="#第一章绪论" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题什么是操作系统">问题：什么是操作系统<a class="hash-link" href="#问题什么是操作系统" title="标题的直接链接">​</a></h3><p>计算机的硬件、软件有一种层次关系。硬件在最底层，上层是操作系统，然后是安装的各种应用程序。操作系统是裸机上的第一层软件，是对硬件功能的首次扩充。</p><p>引入操作系统的目的是：</p><ol><li><strong>接口。</strong>提供一个计算机用户与计算机硬件系统之间的 <strong>接口</strong>；</li><li><strong>控制资源</strong>。有效地 <strong>控制和管理</strong> 计算机系统中的各种软件 / 硬件资源。</li><li><strong>工作流程</strong>。合理地组织计算机系统的 <strong>工作流程</strong>，以改善系统性能。</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题操作系统的功能和服务">问题：操作系统的功能和服务<a class="hash-link" href="#问题操作系统的功能和服务" title="标题的直接链接">​</a></h3><p>五大基本功能：处理器管理、存储器管理、设备管理、文件管理、用户接口。</p><ol><li><strong>处理器管理</strong>：处理器的分配和运行以 <strong>进程</strong> 为基本单位，对处理器管理就是对 <strong>进程的管理</strong><ul><li>进程控制：负责进程的创建、撤销、状态转换</li><li>进程同步：对并发执行的进程进行协调；</li><li>进程通信：负责完成进程间的信息交换</li><li>进程调度：按一定算法进行处理器分配（7）</li></ul></li><li><strong>存储器管理</strong>：对内存进行分配、保护、扩充。<ul><li>内存分配：按一定策略为每道程序分配内存；</li><li>内存保护：保证各程序在自己的区域内运行，而不相互干扰。</li><li>内存扩充：借助虚拟存储技术，获得增加内存的效果。</li></ul></li><li>设备管理：对计算机系统内的所有设备进行管理。<ul><li>设备分配：采用缓冲技术、虚拟技术，使设备与主机并行工作。</li><li>设备传输控制：实现物理 I/O，即启动设备、中断处理、结束处理等。</li><li>设备独立性：用户程序中的设备与实际使用的物理设备无关。</li></ul></li><li>文件管理：对文件系统的管理：<ul><li>文件存储空间管理：合理的分配与回收</li><li>目录管理：提供科学的数据结构，实现高效检索。</li><li>文件操作管理：完成文件的读写操作。</li><li>文件保护：解决文件的共享、保密、保护问题。</li></ul></li><li>用户接口<ul><li>命令接口：提供一组命令供用户控制自己的作业。</li><li>程序接口：也称 <strong>系统调用</strong>。用户可在程序中使用这组系统调用命令，向操作系统提出：使用外设、申请分配内存、磁盘文件读写等操作。</li><li>图形接口：也就是图形化命令接口。</li></ul></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题操作系统的发展--分类">问题：操作系统的发展 / 分类<a class="hash-link" href="#问题操作系统的发展--分类" title="标题的直接链接">​</a></h3><ol><li>手工阶段：纸带机。人机速度矛盾。</li><li>批处理阶段：<ul><li>单道批处理（脱机输入输出技术）<ul><li>缓解人机速度矛盾。资源利用率低没解决。</li></ul></li><li>多道批处理（操作系统雏形）<ul><li>提高资源利用率（多道程序并发执行）。没有人机交互。</li></ul></li></ul></li><li>分时操作系统（cpu 运行分时间片，任务轮流上 cpu 处理）<ul><li>提供人机交互。不能优先处理紧急任务。</li></ul></li><li>实时操作系统：<ul><li>硬实时系统（严格在规定时间内完成处理）</li><li>软实时系统（可偶尔违反时间限定）<ul><li>解决了优先处理紧急任务问题。</li></ul></li></ul></li><li>网络操作系统</li><li>分布式操作系统<ul><li>多个分散的处理单元，通过网络连接而成的系统。可以动态的分配任务。</li></ul></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题操作系统的运行环境--运行机制">问题：操作系统的运行环境 / 运行机制<a class="hash-link" href="#问题操作系统的运行环境--运行机制" title="标题的直接链接">​</a></h3><p>对处理器的执行状态，分为两种：</p><ul><li><strong>核心态</strong>：<strong>管态</strong>、<strong>系统态</strong>。操作系统管理程序执行时的状态。具有较高特权，能执行一切指令，能访问所有寄存器、存储区。</li><li><strong>用户态</strong>：<strong>目态</strong>。用户程序执行时机器的状态，权限较低。用户态程序不能直接调用核心态程序，而是通过执行访问核心态的命令，引起 <strong>中断</strong>，由中断系统转入操作系统内的相应程序。</li></ul><p>总结：<strong>用户进程在用户态工作、系统内核在内核态工作。</strong></p><p>特权指令：只能由操作系统内核使用，不允许用户直接使用。如 I/O 指令、设置中断屏蔽指令、清内存指令、存储保护指令、设置时钟指令。</p><p>操作系统的内核：内核指令在核心态工作。</p><ul><li>与硬件紧密的模块：时钟管理、 中断处理、设备驱动<ul><li>时钟管理：操作系统通过时钟管理，向用户提供标准的系统时间。通过时钟中断的管理，实现进程切换、时间片轮转调度。</li><li>中断机制：内核负责保护和恢复中断现场的信息。</li></ul></li><li>运行频率较高的程序：进程管理、存储器管理、设备管理。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题什么是中断--异常">问题：什么是中断 / 异常<a class="hash-link" href="#问题什么是中断--异常" title="标题的直接链接">​</a></h3><p>中断系统的作用：</p><ol><li>让操作系统的内核强行夺回 CPU 控制权；</li><li>使 CPU 从用户态变为内核态；</li></ol><p><strong>中断 / 外中断</strong></p><p>来源：中断信号来自 CPU <strong>外部</strong>，与当前指令无关。中断是在用户态触发的。</p><p>检查时机：CPU 在执行每个指令的周期末尾，CPU检查是否有外中断信号。</p><ul><li>时钟中断：时间片到期，需要切换应用进程。将正在执行的应用进程暂停，调用新进程</li><li>I/O 中断：用户进行 I/O 相关操作。正在执行的进程需等待用户输入，因而中断当前操作，等待资源到达。</li><li>硬件中断：硬件故障引起的中断，比如打印机突然没电</li><li>程序中断：程序在执行过程中的 <strong>一般中断</strong>。比如上文的 I/O 中断。</li></ul><p><strong>异常 / 内中断</strong></p><p>来源：中断信号来自 CPU 内部，与当先执行的指令相关。</p><p>检查时机：CPU 在执行指令时，随时检查是否有异常发生。</p><ul><li>陷阱 / 陷入 / trap：应用程序故意引发。</li><li>故障 / fault：进程的条件错误、条件不满足、CPU修复故障后继续。（缺页故障）</li><li>终止 / abort：致命错误，无法修复，终止进程。（整数除 0、非法使用特权指令）</li></ul><p><strong>通常异常会引起中断，而中断未必是异常引起。</strong></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题什么是系统调用">问题：什么是系统调用<a class="hash-link" href="#问题什么是系统调用" title="标题的直接链接">​</a></h3><p>系统调用是操作系统对应用程序/程序员提供的接口，API (Application Programming Interface)。</p><p>系统调用和中断在用户态发生，在核心态处理。</p><p>通过系统调用，可以把程序的请求传给内核，内核在完成相应的处理后，再返回给程序。</p><ul><li>用户进程在 <strong>用户态</strong>，通过 <strong>陷入</strong> 指令，执行系统调用，让进入操作系统的系统内核。</li><li>此时操作系统转化为 <strong>内核态</strong>。系统内核执行相应的 <strong>系统调用函数</strong>，然后将处理结果返回给用户进程。</li><li>此时操作系统再切换为 <strong>用户态</strong>，用户进程拿到结果，程序继续运行。</li></ul><p>系统调用的功能有：</p><ul><li>进程管理、文件操作、设备管理、主存管理、进程通信、信息维护。</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="第二章进程管理">第二章：进程管理<a class="hash-link" href="#第二章进程管理" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题什么是进程">问题：什么是进程<a class="hash-link" href="#问题什么是进程" title="标题的直接链接">​</a></h3><p><strong>是系统进行资源分配、运行调度的基本单位。</strong></p><p>通过进程、程序来定义进程：</p><p>程序：静态（静止的有序代码）、永久（在外存中存放）、一个程序可以产生多个进程。</p><p>进程：动态（在执行中的程序）、暂时（在内存中运行）、一个进程可以调用多个程序。</p><p>通过引入进程的原因来定义进程：</p><ul><li>下一个问题</li></ul><p>从进程的 5 特征来定义进程：</p><ol><li>动态性。最基本特性，执行的过程是动态可控、可调整的。</li><li>并发性。多个进程可同时存在内存中，可同时运行。</li><li>独立性。进程是独立运行、资源分配和调度的基本单位。</li><li>异步性。各个进程的各自独立、不可预知的速度推进。</li><li>结构性。每个进程：PCB + 程序段 + 数据段组成。<ul><li>PCB 进程控制块：唯一标识进程、存储控制信息、资源分配信息等。</li><li>程序段：程序的指令代码。</li><li>数据段：运行中需要的、产生的数据。</li></ul></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题为什么引入进程">问题：为什么引入进程<a class="hash-link" href="#问题为什么引入进程" title="标题的直接链接">​</a></h3><p>程序的执行是顺序的，具有 3 个特性：</p><ul><li>顺序性：处理器的操作严格按照程序的规定顺序执行。完成当前操作才做下一个操作。</li><li>封闭性：程序一旦开始运行，独占系统的所需资源，这些资源只有本程序才能改变。</li><li>可再现性：程序执行时的初始条件、执行环境相同，重复执行时，结果一定相同。</li></ul><p>当操作系统引入 <strong>并发</strong>：</p><p>程序的并发执行：若干程序同时在系统中运行，这些程序的执行在时间上是重叠的，即一个程序的执行尚未结束，另一个程序的执行已经开始。</p><ul><li>优点：提高系统的处理能力和资源利用率。<ul><li>可以合理的分配： I/O 资源、网络资源、CPU 处理资源、磁盘读写资源等。</li></ul></li></ul><p>这导致了程序失去了特性：</p><ul><li><strong>间断性</strong>。程序在并发执行时，相互是制约关系，在资源共享时，程序常间断执行。</li><li><strong>失去封闭性</strong>。程序在执行时，必然受到其他程序的影响，资源不是独立占据并使用的。</li><li><strong>不可再现性</strong>。程序并发执行时，失去了封闭性，每次执行环境不同，结果也可能不同。</li></ul><p>当操作系统引入 <strong>进程</strong>：</p><p>为了使程序在并发时保持封闭性和可再现性，需要对资源共享进行更合理的调配。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题进程的状态与转换">问题：进程的状态与转换<a class="hash-link" href="#问题进程的状态与转换" title="标题的直接链接">​</a></h3><p> 5 + 2 种状态：</p><ul><li><p>正常流程：创建态 ➡️ 就绪态 ➡️ 运行态 ➡️ 终止态；</p></li><li><p>发生阻塞：阻塞态；</p></li><li><p>两个挂起：阻塞挂起、就绪挂起；</p></li></ul><p>创建态：进程正在创建的状态。创建 PCB，填入信息 ➡️ 分配需要的资源。</p><p>就绪态：进程已经获得除 CPU 以外的所有资源，一旦获得 cpu 资源，就可以立即执行。</p><p>执行态 / 运行态：进程在 cpu 上执行时的状态。</p><p>阻塞态 / 等待态：进程因发生事件而 <strong>暂停</strong>，无法执行的状态。通常在等待资源。</p><p>终止态 / 结束态：回收进程的资源 ➡️ 撤销 PCB。正常执行完毕，也有可能异常退出。</p><p>挂起：排队的过程。从内存调入外存。进程映像放在外存中。</p><p>5 状态模型：</p><p><img loading="lazy" alt="截屏2022-08-12 18.53.00" src="/assets/images/截屏2022-08-12 18.53.00-ef93c1a8146719db9b6cdadbf3383041.png" width="2300" height="964" class="img_E7b_"></p><p>7 状态模型</p><p><img loading="lazy" alt="截屏2022-08-12 18.51.39" src="/assets/images/截屏2022-08-12 18.51.39-d2bbaa79a179999107f239485de14949.png" width="1262" height="596" class="img_E7b_"></p><p>总结：</p><p><strong>执行态</strong> 可以切换到：</p><ul><li>阻塞状态：是因为请求并等待事件发生</li><li>就绪状态：是因为时机片用完、抢占式调度中有优先级任务需要执行。</li><li>终止状态：进程执行完毕、异常中断，需要销毁。</li></ul><p>只有 <strong>就绪态</strong>，可以切换到 <strong>执行态</strong>。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题进程的控制和通信">问题：进程的控制和通信<a class="hash-link" href="#问题进程的控制和通信" title="标题的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="进程的控制">进程的控制<a class="hash-link" href="#进程的控制" title="标题的直接链接">​</a></h4><p>概念：实现进程的创建、状态转换。通过 <strong>原语</strong> 实现控制，本质是关 / 开中断实现。</p><p>原语的工作：</p><ol><li><strong>进程的状态切换。</strong>更新 PCB 信息（修改进程运行状态、保存/恢复进程运行环境）；</li><li><strong>进程的阻塞 / 唤醒。</strong>将 PCB 插入合适队列（就绪、阻塞等）；</li><li><strong>进程的创建 / 撤销。</strong>分配 / 回收资源（进程是否撤出/放入内存）；</li></ol><p>原语的内容：</p><ul><li>阻塞原语：P原语。进程 <strong>主动调用</strong>，并切换。（运行 ➡️ 阻塞）</li><li>唤醒原语：V原语。进程被动切换。（阻塞 ➡️ 就绪）</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="进程间的通信">进程间的通信<a class="hash-link" href="#进程间的通信" title="标题的直接链接">​</a></h4><p>低级通信方式</p><ul><li>P 原语、V 原语：实现进程的同步、互斥</li></ul><p>高级通信方式</p><ol><li><p>共享存储</p><ul><li>一个互斥访问的共享存储区。</li></ul></li><li><p>管道通信</p><ul><li>管道为一个共享的、互斥访问的特殊共享文件。</li><li>一个管道：半双工通信。两个管道：全双工。</li><li>管道中必须全满 / 全空，才可以继续操作（读/写）。</li></ul></li><li><p>消息传递</p><ul><li>消息为单位通信（消息头/消息尾）。通过系统的 ‘发送/接受原语’ 实现。</li><li>直接通信方式：直接挂到接收方的消息队列中</li><li>间接通信方式（信箱）：通过信箱中间体。</li></ul></li><li><p>socket</p><ul><li>它可用于不同机器间的进程通信</li></ul></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题为什么要引入线程">问题：为什么要引入线程<a class="hash-link" href="#问题为什么要引入线程" title="标题的直接链接">​</a></h3><p><strong>区分：线程是 CPU 调度的基本单位、进程是资源分配的基本单位。</strong></p><p>进程的特点：</p><ul><li>进程是一个用有资源的独立单元</li><li>进程同时又是一个可以被处理器独立调度和分配的单元。</li></ul><p>存在的缺点：</p><ul><li>操作系统还需要进行：进程创建、撤销、状态切换。进行这些操作时，需要为进程分配资源和回收资源，同时要保存进程现场信息，付出了较大时空开销。</li></ul><p>解决思路：</p><ul><li>在系统中尽量少的创建进程、尽量低频的切换进程。</li></ul><p>解决方式：</p><ul><li>将进程的两个特点切分，让进程只完成第一个任务：资源独立的单元，线程去完成第二个任务：CPU 调度的基本单位。</li></ul><p>总结：</p><p>引入进程的目的，是让多个程序可以并发执行，以改善资源利用率，提高系统吞吐量。</p><p>引入线程的目的，是减少程序并发执行时所付出的时空开销，使操作系统更好的并发性。</p><ul><li>线程是进程内相对独立的、可调度的执行单元。线程自己基本不拥有资源，只在运行时占用一点资源（程序计时器、寄存器、栈），同一个进程内的资源，线程相互共享。</li></ul><p>同一进程内的线程：</p><ol><li>内存地址共享。</li><li>资源共享。</li><li>线程间的通信无需经过操作系统。</li><li>线程的切换，不会倒车进程的切换。</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题线程的实现">问题：线程的实现<a class="hash-link" href="#问题线程的实现" title="标题的直接链接">​</a></h3><p><strong>用户级线程</strong>：不需要操作系统。进程通过线程库控制线程。</p><ul><li>优：线程调度不需要用户态 / 内核态切换。速度极快。</li><li>缺：一个线程阻塞，整个进程等待（时间片是分配给进程的，CPU看不到线程，不知道阻塞，不会切换线程）</li></ul><p><strong>内核级线程</strong>：操作系统实现线程，完成线程的创建和销毁工作。</p><ul><li>优：一个线程阻塞由于 IO 阻塞时，不影响其他线程运行（时间片是分配给线程的，CPU 可以感知到阻塞，然后主动切换）</li><li>缺：切换速度慢，依赖内核态。</li></ul><p><strong>两种组合</strong>：用户、内核都可以建立线程，各取优点。</p><ul><li>一对一：一个用户级线程，映射，一个内核级线程<ul><li>优：并发度高。线程都可以分配到CPU并发执行。</li><li>缺：开销大。操作系统管理线程太多。</li></ul></li><li>一对多：多个用户级线程，映射，一个内核级线程<ul><li>优：开销小。管理高效。</li><li>缺：并发度低。若一个线程阻塞，则无法调度其他线程，整个进程阻塞。</li></ul></li><li>多对多：开销小，并发度高</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题处理器的三级调度">问题：处理器的三级调度<a class="hash-link" href="#问题处理器的三级调度" title="标题的直接链接">​</a></h3><p>调度是操作系统的基本功能。CPU 是计算机的首要资源，所以调度设计均围绕如何高效利用 CPU 资源而展开。异构作业从提交到执行，通常要经历多级调度。</p><ul><li>高级调度（作业）：在队列中挑选一个作业，外存进内存，添加资源 + 创建进程。<ul><li>无  ==&gt;  创建态  ==&gt;  就绪态</li></ul></li><li>中级调度（内存）：队列中，外存进内存，挂起变就绪。<ul><li>挂起就绪态  ==&gt;  就绪态</li><li>挂起阻塞态  ==&gt;  阻塞态</li></ul></li><li>低级调度（进程）：队列中，内存进 CPU。<ul><li>就绪态  ==&gt;  运行态</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题调度算法-7">问题：调度算法 (7)<a class="hash-link" href="#问题调度算法-7" title="标题的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="进程调度的时机">进程调度的时机<a class="hash-link" href="#进程调度的时机" title="标题的直接链接">​</a></h4><ul><li>进程主动放弃<ul><li>进程执行完毕，终止进程。</li><li>进程主动阻塞，等待所缺资源，如 I/O 操作、网络资源。</li></ul></li><li>进程被动放弃<ul><li>时间片用尽。</li><li>CPU 被抢占，高优先级进程在就绪态。</li><li>紧急事件处理，如 I/O中断，杀进程。</li></ul></li></ul><p>抢占式：如果有高优先级进程进入就绪态，就会让正在处理的进程挂起。</p><p>非抢占式：不会让正在处理的进程挂起，而是等待执行完成，或主动进入阻塞态时，再执行。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="批处理系统-3">批处理系统 (3)<a class="hash-link" href="#批处理系统-3" title="标题的直接链接">​</a></h4><p>先来先服务 FCFS（作业调度、进程调度）</p><ul><li><p>按照队列的思路，先排队的先执行，没有优先级概念。</p><ul><li><p>优：公开、实现简单。进程不会饥饿。</p></li><li><p>缺：对长作业有利，短作业不利。短作业周转时间长，等待的时间过多。</p></li></ul></li></ul><p>短作业优先 SJF（非抢占）（作业调度、进程调度）</p><ul><li><p>在挂起就绪的队列中，周期性评估可以最短完成的作业，然后优先让它们执行。</p><ul><li><p>优：平均等待时间、平均周转时间最短。</p></li><li><p>缺：长作业不利，会饥饿</p></li></ul></li></ul><p>高响应比优先 HRRN（ only 作业调度）</p><p>综合了任务的等待时间和预估运行时间，形成相应比公式。</p><ul><li><p>响应比 =（等待时间 + 预估运行时间）/ 预估运行时间  &gt;= 1</p></li><li><p>优：综合优点：综合短作业优先（预估运行时间）、先来先服务（等待时间）
避免缺点：防止长作业饥饿（等待时间长，则优先服务）。</p></li><li><p>缺：响应比的计算需要开销。</p></li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="实时操作系统-4">实时操作系统 (4)<a class="hash-link" href="#实时操作系统-4" title="标题的直接链接">​</a></h4><p>时间片轮转（抢占）（only 进程调度）</p><p>所有进程按照先来先服务进入队列，CPU 资源按照时间片划分，到时间后就挂起当前的进程，切换下一个进程进场使用 CPU 资源。</p><ul><li><p>优：公平、响应快、适用于分时操作系统。所有进程都不会饥饿。</p></li><li><p>缺：进程切换频率高，状态切换需要开销。不能区分任务的紧急程度。</p></li></ul><p>优先级调度（抢占 / 非抢占）（作业调度、进程调度）</p><ul><li><p>根据系统需求，可以对任务进行优先级划分。然后高优任务先执行。</p><ul><li><p>优：区分紧急程度，适用于实施操作系统。灵活调整优先级偏好。</p></li><li><p>缺：高优先级过多，低优先级的进程就会饥饿。</p></li></ul></li></ul><p>多级队列调度（非抢占）（进程调度）</p><ul><li>将等候的进程划分多个队列，每个队列都采用各自的调度算法。</li></ul><p>多级反馈队列调度（抢占）（进程调度）</p><ul><li><p>多级队列：依然划分多个队列，每个队列优先级从高到低，时间片从小到大。</p></li><li><p>每个队列：队列内统一按照 <strong>先来先服务</strong>。</p></li><li><p>当新进程进入调度时，首先放入第一个队列（高优 + 短时）的队尾，等待执行。如果在划分好的时间片内没有执行完毕，则重新放入第二个队列的队尾。以此类推。最后一个队列无法再往下分，则使用 <strong>时间片轮转调度算法</strong>。</p><ul><li><p>优：公平（先来先服务），新进程快速响应（高响应比优先），短进程快速处理（多作业优先），灵活偏好（优先级）</p></li><li><p>缺：会饥饿（如果第一个队列没执行完，会一直运行第一个队列的进程）</p></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题进程的同步--互斥">问题：进程的同步 / 互斥<a class="hash-link" href="#问题进程的同步--互斥" title="标题的直接链接">​</a></h3><p>同步和互斥的区别：</p><ul><li><p>同步，直接相互制约：有先后次序的需求，不同类型的进程。 </p></li><li><p>互斥，间接相互制约：有争用资源的需求，相同类型的进程。 </p></li></ul><p><strong>同类进程即为互斥关系、不同类进程即为同步关系。</strong></p><ul><li>消费者和生产者就是同步关系、消费者和消费者就是互斥关系。</li></ul><p>互斥存在临界资源：</p><ul><li>临界资源：同时只允许一个进程使用的资源。入打印机、绘图机等。</li></ul><p>访问临界资源的过程：</p><p>进入区：检查是否可进入，上锁🔒的代码，对即将进入的进程添加访问标记。</p><p>临界区：临街段，进程中访问临界资源的代码。</p><p>退出区：解锁🔓的代码，对访问结束的进程删除访问标记。</p><p>剩余区：其余代码，进程中除上述 3 部分以外的代码。</p><p><img loading="lazy" alt="临界区互斥-来源参考[3]" src="/assets/images/1fa1353e587e4fe8ab0967538699492d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0-e7ff4a20fd3ccd76d8c424bf5ea5c27a.awebp" width="929" height="471" class="img_E7b_"></p><p>互斥的原则（4）</p><ul><li>空闲让进：临界区空闲，则允许进程访问。</li><li>忙则等待：临界区占用，则禁止其他进程访问。</li><li>有限等待：不会饥饿，有限时间内，一定会进入临界区。</li><li>让权等待：不满足条件的进程，不会盲等，占用CPU资源。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题互斥的实现">问题：互斥的实现<a class="hash-link" href="#问题互斥的实现" title="标题的直接链接">​</a></h3><p>有 4 + 2 种方式：核心思想就是如何 <strong>加锁</strong>。</p><p><strong>软件方式</strong></p><div class="codeBlockContainer_I0IT language-typescript theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-typescript codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 单标志法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 公用 turn 标志进程号。谁先进去，谁就修改一下 turn。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 缺：进入时只检查，不上锁。退出时给对方解锁，给自己上锁（转交使用权）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 不满足：空闲让进。必须进程交替进入。</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>双标志先检查法<ul><li>数组 flag<!-- -->[ false, false ]<!-- -->。先检查，后上锁🔒。进程只修改自己的标志。</li><li>缺：检查和上锁无法一气呵成。</li><li>优：解决空闲让进。不需要交替进入</li><li>不满足：忙则等待。若同时检查通过，会同时进入。</li></ul></li><li>双标志后检查法<ul><li>数组 flag<!-- -->[  ]<!-- -->。先上锁🔒，后检查。进程只修改自己的标志。</li><li>缺：检查和上锁无法一气呵成。</li><li>优：解决忙则等待。先上锁确保不会同时进入。</li><li>不满足：空闲让进 + 有限等待。同时上锁，都进不去，产生饥饿。</li></ul></li><li>Peterson 算法（皮特森算法）<ul><li>算法 1 和 3 的结合。flag<!-- -->[false, false ]<!-- --> = 希望进入；turn = 谦让。<ul><li>利用 flag[] 解决资源互斥访问、利用 turn 解决进程饥饿。比如 p0 进程想要读区资源，会把自己位置的 flag<!-- -->[0]<!-- --> 置为 true，然后把 ture = 1 谦让对方先执行。接下来判断：<code>while(flag[1] &amp;&amp; turn = 1)</code> 就一直等待。直到 p1 的 flag 位置调整为 false，或 turn 指向自己 0。<ul><li>flag<!-- -->[1]<!-- --> 为真表示 p1 希望访问，turn 为 1 表示 p1 可以访问。</li></ul></li></ul></li><li>进入区：表明想用 ➡️ 主动谦让 ➡️ 检查（对方是否想进，我是否谦让）</li><li>检查：对方想进 且 我主动谦让，则循环等待。 while ( flag<!-- -->[1]<!-- -->=true &amp;&amp; turn==1 )</li><li>优：综合上面三种方法，解决：空闲让进、忙则等待、有限等待。</li><li>缺：不满足让权等待（四个方法都不满足）一直占用 CPU。</li></ul></li></ul><p><strong>硬件方式</strong></p><div class="codeBlockContainer_I0IT language-typescript theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-typescript codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 中断屏蔽法 和 硬件指令法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 开</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">关中断指令，利用 </span><span class="token operator" style="color:#393A34">**</span><span class="token plain">原语</span><span class="token operator" style="color:#393A34">**</span><span class="token plain">，确保检查和上锁一气呵成，不被打断。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 优：简单、易于实现。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 缺：</span><span class="token keyword control-flow" style="color:#00009f">while</span><span class="token plain"> 一直循环等待，违背让权等待，产生饥饿。</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题信号量">问题：信号量<a class="hash-link" href="#问题信号量" title="标题的直接链接">​</a></h3><p>引入信号量：</p><p>解决进程互斥，上述提到了 6 种方式。软件方法存在算法复杂、效率不高、违背 <strong>忙则等待</strong> 原则的问题；硬件方法存在违背 <strong>让权等待</strong> 的缺点。</p><p>信号量是一种同步机构，一种协调进程间共享资源访问的⽅法。</p><ul><li>解决了让权等待，忙则等待，不会浪费 CPU 资源。</li></ul><p>解决方式：通过原语的 开、关 中断，一气呵成，实现上锁🔒的不可被打断。</p><div class="codeBlockContainer_I0IT language-js theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-js codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// semaphore 信号量 = 资源数量统计 + 等待队列</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> s </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">count</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">10</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">queue</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// P 操作：🔒 + 申请 / 使用资源</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token function-variable function" style="color:#d73a49">wait</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">p</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">count</span><span class="token operator" style="color:#393A34">--</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">s</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">count </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block 原语  </span><span class="token comment" style="color:#999988;font-style:italic">// 阻塞该进程: 进程挂起到阻塞队列</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">queue</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">unshift</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">p</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 将该 p 进程插入等待队列 s.queue</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// p进程使用资源</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// V 操作：🔓 + 释放/ 产生资源</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token function-variable function" style="color:#d73a49">signal</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">p</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  s</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">count</span><span class="token operator" style="color:#393A34">++</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">s</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">count </span><span class="token operator" style="color:#393A34">&gt;=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">queue</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">pop</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 队列中取出最后一个进程p</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    weakup 原语 </span><span class="token comment" style="color:#999988;font-style:italic">// 将p放入就绪队列，等待执行</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="信号量的使用">信号量的使用<a class="hash-link" href="#信号量的使用" title="标题的直接链接">​</a></h4><p>实现进程同步：先 V 后 P。</p><ul><li>初始资源值为 0。先生产资源、再消费资源。</li></ul><p>举例：P1 中有语句 S1，P2 中有语句 S2。要求 S1 必须在 S2 之前执行。</p><div class="codeBlockContainer_I0IT language-js theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-js codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// 设置信号量初始值</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">semaphore</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">count </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">P1</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">S1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">V</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">count</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">P2</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">P</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">count</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">S2</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>实现进程互斥：先 P 后 V</p><ul><li>初始资源值为 1。先执行的进程，优先消费资源，后执行的进程只能等待。</li></ul><div class="codeBlockContainer_I0IT language-js theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-js codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// 设置信号量初始值</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">semaphore</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">count </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">P1</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">P</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">count</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// P1 的临界代码</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">V</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">count</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">P2</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">P</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">count</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// P2 的临界代码</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">V</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">count</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="死锁饥饿活锁死循环的区别">死锁、饥饿、活锁、死循环的区别<a class="hash-link" href="#死锁饥饿活锁死循环的区别" title="标题的直接链接">​</a></h3><ul><li>死锁：(<strong>争用公共资源</strong>) 多个进程之间，相互竞争资源，陷入无期限地等待其他进程占有的资源，都在阻塞等待。</li><li>饥饿：(<strong>优先级问题</strong>) 某一个进程，因任务调度问题，长期得不到资源而阻塞。(短作业优先) 如果长期无法执行，该进程则处在 <strong>饿死</strong> 状态。</li><li>活锁：在忙时等待条件下发生的饥饿，称之为“活锁”。例如不公平的互斥算法，让某些进程一直在等待被占用的资源，这实际上也是优先级的问题。</li><li>死循环：某一个进程，在 while、for 等逻辑内，跳不出循环。(P V 操作)</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="死锁--饿死的区别">死锁 / 饿死的区别<a class="hash-link" href="#死锁--饿死的区别" title="标题的直接链接">​</a></h4><p>共同点：死锁 / 饿死都是因 <strong>竞争资源</strong> 而引起的。</p><p>不同点：</p><p>从所争资源考虑：</p><ul><li>死锁：死锁进程等待的是永远也不会释放的资源。</li><li>饿死：饿死进程等待的是会释放、但永远也不会分配给自己的资源。</li></ul><p>从进程状态考虑：</p><ul><li>死锁：一定发生了循环等待 (哲学家困境)，可以通过资源分配图检测出。</li><li>饿死：没有循环等待，无法通过资源分配图检测。</li></ul><p>从涉事人员考虑：</p><ul><li>死锁：一定是两个以上的进程，都发生了死锁。</li><li>饿死：一个进程就可能被饿死。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题什么是死锁">问题：什么是死锁<a class="hash-link" href="#问题什么是死锁" title="标题的直接链接">​</a></h3><p>通过 <strong>哲学家问题</strong> 引发的死锁。</p><ul><li>5 个哲学家围坐一张桌子。桌子上有 5 根筷子，分别放在每个哲学家之间。哲学家的动作有：思考、进餐两种。进餐时需要同时拿起左右手的两根筷子，思考时需要将左右手的筷子放回原处。</li><li>这就是并发进程执行时，处理临界问题面临的困局。筷子是临界资源，不能被两个哲学家一起使用，仅此用一个信号量数组来表示筷子。</li><li>死锁僵局：当 5 个哲学家同时饥饿而各自拿左边的筷子时，会导致 5 根筷子均被占用，当他们要拿右手筷子时，会因没有筷子而无限等待，但是又不愿放弃左手的筷子，这就是所谓 <strong>让权等待</strong> 原则。</li></ul><p>解决方式：规定奇数号的哲学家先拿左边筷子，然后拿右边筷子；偶数号的哲学家相反。</p><p>定义：当多个进程因竞争系统资源或相互通信，而处于永久阻塞状态。若无外力作用，僵局无法打破，这些进程都会陷入无期限地等待其他进程占有的、自己无法得到的资源。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题死锁产生的条件">问题：死锁产生的条件<a class="hash-link" href="#问题死锁产生的条件" title="标题的直接链接">​</a></h3><p>围绕资源，死锁产生的原因有两点：<strong>系统资源不足</strong> (根本原因)、<strong>进程推进顺序不当</strong>。</p><p><strong>死锁产生必须满足 4 个条件</strong>：</p><ul><li><strong>互斥条件</strong>：进程间的资源必须互斥。一段时间内某种资源仅为一个进程所占有。</li><li><strong>不剥夺条件</strong>：进程掌握的资源无法强制剥夺收回，只能由进程使用完后，主动释放。</li><li><strong>请求和保持条件</strong>： 进程已经申请到一部分资源，在等待分配其他需求资源的同时，继续占有已经分配到的资源，不释放。</li><li><strong>环路等待条件</strong>：进程间发生了循环等待链条，也就是哲学家困境。需要的资源被其他进程持有，这样形成了一个资源的循环等待链。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题死锁的处理">问题：死锁的处理<a class="hash-link" href="#问题死锁的处理" title="标题的直接链接">​</a></h3><p>主要有 4 种思路：</p><ul><li>不处理：鸵鸟算法。</li><li>预防死锁：静态处理，预先破坏产生死锁的 4 条件中的某些条件。</li><li>避免死锁：动态处理，在分配资源过程中，用算法（银行家算法），防止发生死锁。</li><li>死锁的检测和解除：发生死锁后解决。通过系统检测，及时发现死锁，然后解决。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题死锁的预防--避免">问题：死锁的预防 / 避免<a class="hash-link" href="#问题死锁的预防--避免" title="标题的直接链接">​</a></h3><p><strong>预防死锁</strong> 和 <strong>避免死锁</strong> 是不一样的：</p><ul><li>两种都在死锁产生之前，实施措施，不同的是：</li><li><strong>死锁预防</strong> 是非常严格的，通常会对系统并发性造成很大副作用，同时也不需要再添加额外的算法去避免死锁。</li><li><strong>死锁避免</strong> 对系统附加条件相关宽松，有利于并发，但在资源被分配出去之前要计算分配之后系统是否安全，有额外的算法开销。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="死锁的预防">死锁的预防<a class="hash-link" href="#死锁的预防" title="标题的直接链接">​</a></h4><p>只需破坏产生死锁的 4 个必要条件之一即可：</p><ul><li>破坏互斥：<ul><li>让资源不再互斥：临界资源改为共享资源（SPOOLing技术）</li><li>缺点：有些资源（🖨️）无法变为共享资源，可行性低。</li></ul></li><li>破坏不可剥夺：<ul><li>当进程已经获得一部分资源，而剩余资源无法满足时，有两种思路：<ol><li>强制释放自己的所有资源；</li><li>按照优先级，剥夺别人的资源（优先级）。</li></ol></li><li>缺：算法开销大，有些进程会饥饿，被随意剥夺资源可能会造成严重后果。</li></ul></li><li>破坏请求和保持：<ul><li>静态分配的办法，进程一次性申请全部所需资源，预先分配好全部资源，才运行</li><li>缺：资源利用率低，有些进程迟迟得不到资源，会饥饿。</li></ul></li><li>破坏循环等待：<ul><li>有序资源分配。资源按不同类型编号；进程申请资源必须从小到大，有序申请。</li><li>比如给打印机为1，磁带机为2，进程必须从1到2申请，不能反着申请。</li><li>缺：不便于新增设备，资源利用率低，编程困难。</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="死锁的避免">死锁的避免<a class="hash-link" href="#死锁的避免" title="标题的直接链接">​</a></h4><p>动态方法：在系统进行资源分配前，先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则分配，否则不分配，进程继续等待。</p><ul><li>安全状态：系统不会死锁，则该序列为安全序列。</li><li>不安全状态：系统不稳定，有可能会死锁，也有可能会回到安全状态。</li><li>安全性算法：寻找安全序列 —— 银行家算法 🏦</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="银行家算法">银行家算法<a class="hash-link" href="#银行家算法" title="标题的直接链接">​</a></h4><blockquote><p><a href="https://www.bilibili.com/video/BV1Nx411X7hT?spm_id_from=333.337.search-card.all.click&amp;vd_source=591709e27d352a97b88a4c9ec8b2ad39" target="_blank" rel="noopener noreferrer">🔗</a></p></blockquote><p>通过多个进程资源分配表：</p><table><thead><tr><th>进程最大需求量</th><th>已经分配量</th><th>还需要的量</th><th>系统剩余资源</th><th>申请的量</th></tr></thead><tbody><tr><td>max</td><td>Allocation</td><td>Need</td><td>Available</td><td>Reques</td></tr></tbody></table><p>步骤：</p><div class="codeBlockContainer_I0IT language-typescript theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-typescript codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token number" style="color:#36acaa">1.</span><span class="token plain"> 检查申请是否超过这个进程之前申请的最大需求量；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">1.</span><span class="token plain"> 检查系统剩余可用资源是否满足；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">1.</span><span class="token plain"> 模拟分配，使用安全性算法，寻找安全序列（就是资源先给谁，后给谁）</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题死锁的检测--解除">问题：死锁的检测 / 解除<a class="hash-link" href="#问题死锁的检测--解除" title="标题的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="死锁的检测">死锁的检测<a class="hash-link" href="#死锁的检测" title="标题的直接链接">​</a></h4><p>数据结构：资源分配图 (有向图)</p><ul><li>两种结点：进程结点(一个进程)、资源结点(一类资源，有数量)</li><li>两种边：申请边、分配边</li></ul><p>检测方式：</p><ol><li>找到可能形成孤立的、 不阻塞的进程结点，即它已经获得了所有所需资源，可以继续运行知道进程执行完毕，然后释放持有资源。</li><li>假设该可能孤立的进程释放资源后，消除其持有资源的边，简化资源分配图。</li><li>重复这一过程，直到不可再简化：<ul><li>若能消除所有边 ➡️ 可完全简化的，没有死锁</li><li>不能消除所有边 ➡️ 发生死锁</li></ul></li></ol><h4 class="anchor anchorWithStickyNavbar_mojV" id="死锁的解除">死锁的解除<a class="hash-link" href="#死锁的解除" title="标题的直接链接">​</a></h4><p>资源剥夺法：从其他进程中抢占所需资源，挂起这些进程，让自己解除死锁状态。</p><p>撤销进程法：终止某些进程，让它们归还占用资源，然后分配给其他进程，解除死锁状态。</p><p>进程回退法：让一些进程回退到系统不死锁的状态，进程自愿释放资源，而不是剥夺。这要求系统保持进程的历史信息，设置还原点。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题并行--并发的区别">问题：并行 / 并发的区别<a class="hash-link" href="#问题并行--并发的区别" title="标题的直接链接">​</a></h3><p>并发：一条赛道，同步执行。并发是单核 CPU 的一种调度算法。通过时间片轮转，给不同的进程都有公平参与执行的机会，不会导致进程饿死。因切换速度足够快，宏观上看似多个进程在同时执行。</p><p>并行：多条赛道，同时执行。就是多核 CPU，可以各自管理，真正的同时执行多个进程。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="第三章内存管理">第三章：内存管理<a class="hash-link" href="#第三章内存管理" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题内存管理的功能">问题：内存管理的功能<a class="hash-link" href="#问题内存管理的功能" title="标题的直接链接">​</a></h3><ol><li>内存空间分配 / 回收：连续 / 非连续 分配。</li><li>扩充内存：对内存空间的扩充，采用 覆盖、交换、虚拟 等方式。</li><li>地址变换：相互转换：程序中使用的逻辑地址，和内存中实际的物理地址</li><li>内存保护：(两种寄存器) 保证不同作业互不干扰，防止作业 A 发生错误而破坏作业 B</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题内存的扩充">问题：内存的扩充<a class="hash-link" href="#问题内存的扩充" title="标题的直接链接">​</a></h3><p><strong>覆盖技术</strong> (早期操作系统)</p><ol><li>一个大程序划分为若干‘覆盖’ = 程序段</li><li>内存中：一个固定区 (主程序)。不会掉入调出。存放最活跃的程序段。</li><li>内存中：若干覆盖区。互斥的 ‘覆盖’，可共享一个覆盖区，运行时动态掉入调出。</li></ol><ul><li>缺点：程序员需要声明覆盖结构，不透明，增加编程负担。</li></ul><p><strong>交换技术</strong> (内存调度)</p><ul><li>当缺页率频发、内存不足时，执行交换技术。</li></ul><ol><li>内存中：调出某些进程放到外存，保留PCB，移至挂起态。</li><li>外存中：设置文件区、对换区 (交换区)。对换区读取速度快，且有就绪挂起、阻塞挂起队列。</li></ol><p><strong>虚拟技术</strong>（后面一大节）</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题内部碎片--外部碎片">问题：内部碎片 / 外部碎片<a class="hash-link" href="#问题内部碎片--外部碎片" title="标题的直接链接">​</a></h3><p>内部碎片：已经分配给作业，但不能被作业利用的内存空间。</p><p>外部碎片：还没有分配给作业，但由于碎片太小而无法分配给作业的内存空间。</p><p>通俗说，作业占用的内存空间，没有装满，有剩余就是内部碎片。有些内存区域无法分配给作业，就是外部碎片。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题内存的分配">问题：内存的分配<a class="hash-link" href="#问题内存的分配" title="标题的直接链接">​</a></h3><p>内存的空间分类 / 回收，分为 2 个思路：</p><ul><li><strong>连续分配</strong> 3 ：单一连续、固定分区、动态分区</li><li><strong>非连续分配</strong> 3：(可连续、可离散) 基本分页存储管理、段页式存储管理、</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题内存的连续分配-3">问题：内存的连续分配 (3)<a class="hash-link" href="#问题内存的连续分配-3" title="标题的直接链接">​</a></h3><p><strong>单一连续分配</strong> (单道程序)</p><p>最简单的分配方式，系统区是内存低地址部分，给系统使用。</p><ul><li>内存分为：系统区 + 用户区。</li><li>只支持一个程序进入，静态分配，采用覆盖技术扩充内存。</li><li>优：管理简单，无外部碎片。</li><li>缺：单用户、单操作系统，有内部碎片。</li></ul><p><strong>固定分区分配</strong> (多道程序)</p><p>内存事先划分大小不等的固定区域，在运行时不能更改。每个分区可以装入一道程序。</p><ul><li>内存划分：系统区 + 大小不一 (相等) 的固定分区，不再更改。</li><li>设置分区说明表：分区号(隐含)、容量、起始地址、状态(是否分配)。</li><li>程序装入时：找到合适大小的分区装入，不满足则拒绝装入，装入采用静态重定位方式</li><li>优：支持多道程序，无外部碎片。</li><li>缺：有内部碎片，分区固定灵活度不高，利用率低，无法多进程共享一个内存区。</li></ul><p><strong>动态分区分配</strong> (多道程序) / <strong>可变式分区分配</strong></p><ul><li><p>内存划分：系统区 + 用户区。不预先划分，进程要多大，划分多大。</p></li><li><p>一表一链：‘空闲分区表’ + ‘空闲分区链’ ：分区号、容量、起始地址、状态。将空闲的区域通过链表形式串联起来。</p></li><li><p>采用动态分区分配算法 (4)：(下文) 首次、最佳、最差、邻近</p></li><li><p>内存回收：内收内村后，会更新链、表信息。合并问题连续的内存空间。</p><ul><li><p>优：无内部碎片，灵活度，利用率高</p></li><li><p>缺：有外部碎片，可以用紧凑技术解决。动态算法有开销。当有大作业来到时，其存储空间的申请可能会得不到满足。</p></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题动态分区分配算法">问题：动态分区分配算法<a class="hash-link" href="#问题动态分区分配算法" title="标题的直接链接">​</a></h3><p><strong>首次适应算法</strong>：（First Fit，FF）—— <strong>最佳</strong></p><p>把空间分区按照地址递增的次序用链表串联。进程分配内存时顺序查链表，找到第一个符合的，空间足够大的分区进行分配。把该分区划分出和进程所需空间相等的内存，剩余内存用链表继续串联。</p><ul><li><p>优：综合性能最佳，算法开销小，不需要重排列分区。</p></li><li><p>缺：在低地址区，小碎片 (外部碎片) 会越来越多，从低地址查表，浪费开销。</p></li></ul><p><strong>邻近适应算法</strong>：（Next Fit，NF）</p><p>在首次适应算法的基础上，把队列改成循环队列。这样不用每次从队首开始查找，而是从上次查找分区位置开始查找。</p><ul><li><p>优：不需要每次从低地址小分区开始查找，提升速度、算法开销小。</p></li><li><p>缺：高地址的大分区可能储备不足，大进程得不到满足。</p></li></ul><p><strong>最佳适应算法</strong>：（Best Fit，BF）</p><p>链表按照容量递增顺序组织。从小到大查表，优先用最小的。</p><ul><li><p>优：保留许多大分区满足大进程需求</p></li><li><p>缺：产生许多难以利用的小碎片 (外部碎片)，算法开销大，需要频繁重排列链表。</p></li></ul><p><strong>最差适应算法</strong>：（Worst Fit，WF）</p><p>链表容量递减顺序。从大到小查表，优先用最大的。</p><ul><li><p>优：减少小碎片的产生</p></li><li><p>缺：大分区不足，大进程得不到满足，算法开销大，频繁重排列链表。</p></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题解决内存中的碎片问题">问题：解决内存中的碎片问题<a class="hash-link" href="#问题解决内存中的碎片问题" title="标题的直接链接">​</a></h3><p><strong>拼接 / 紧凑 / 紧缩技术</strong>：已分配分区移动到内存一端，让碎片可以合并。</p><p>拼接时机：</p><ol><li>出现分区回收时，就拼接（过于频繁）。</li><li>有作业找不到合适空间 + 内存碎片容量足够时，拼接。 <ul><li>缺点：系统开销大</li></ul></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题内存的非连续分配">问题：内存的非连续分配<a class="hash-link" href="#问题内存的非连续分配" title="标题的直接链接">​</a></h3></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/interview/summary/计算机网络"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">计算机网络</div></a></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#第一章绪论" class="table-of-contents__link toc-highlight">第一章：绪论</a><ul><li><a href="#问题什么是操作系统" class="table-of-contents__link toc-highlight">问题：什么是操作系统</a></li><li><a href="#问题操作系统的功能和服务" class="table-of-contents__link toc-highlight">问题：操作系统的功能和服务</a></li><li><a href="#问题操作系统的发展--分类" class="table-of-contents__link toc-highlight">问题：操作系统的发展 / 分类</a></li><li><a href="#问题操作系统的运行环境--运行机制" class="table-of-contents__link toc-highlight">问题：操作系统的运行环境 / 运行机制</a></li><li><a href="#问题什么是中断--异常" class="table-of-contents__link toc-highlight">问题：什么是中断 / 异常</a></li><li><a href="#问题什么是系统调用" class="table-of-contents__link toc-highlight">问题：什么是系统调用</a></li></ul></li><li><a href="#第二章进程管理" class="table-of-contents__link toc-highlight">第二章：进程管理</a><ul><li><a href="#问题什么是进程" class="table-of-contents__link toc-highlight">问题：什么是进程</a></li><li><a href="#问题为什么引入进程" class="table-of-contents__link toc-highlight">问题：为什么引入进程</a></li><li><a href="#问题进程的状态与转换" class="table-of-contents__link toc-highlight">问题：进程的状态与转换</a></li><li><a href="#问题进程的控制和通信" class="table-of-contents__link toc-highlight">问题：进程的控制和通信</a><ul><li><a href="#进程的控制" class="table-of-contents__link toc-highlight">进程的控制</a></li><li><a href="#进程间的通信" class="table-of-contents__link toc-highlight">进程间的通信</a></li></ul></li><li><a href="#问题为什么要引入线程" class="table-of-contents__link toc-highlight">问题：为什么要引入线程</a></li><li><a href="#问题线程的实现" class="table-of-contents__link toc-highlight">问题：线程的实现</a></li><li><a href="#问题处理器的三级调度" class="table-of-contents__link toc-highlight">问题：处理器的三级调度</a></li><li><a href="#问题调度算法-7" class="table-of-contents__link toc-highlight">问题：调度算法 (7)</a><ul><li><a href="#进程调度的时机" class="table-of-contents__link toc-highlight">进程调度的时机</a></li><li><a href="#批处理系统-3" class="table-of-contents__link toc-highlight">批处理系统 (3)</a></li><li><a href="#实时操作系统-4" class="table-of-contents__link toc-highlight">实时操作系统 (4)</a></li></ul></li><li><a href="#问题进程的同步--互斥" class="table-of-contents__link toc-highlight">问题：进程的同步 / 互斥</a></li><li><a href="#问题互斥的实现" class="table-of-contents__link toc-highlight">问题：互斥的实现</a></li><li><a href="#问题信号量" class="table-of-contents__link toc-highlight">问题：信号量</a><ul><li><a href="#信号量的使用" class="table-of-contents__link toc-highlight">信号量的使用</a></li></ul></li><li><a href="#死锁饥饿活锁死循环的区别" class="table-of-contents__link toc-highlight">死锁、饥饿、活锁、死循环的区别</a><ul><li><a href="#死锁--饿死的区别" class="table-of-contents__link toc-highlight">死锁 / 饿死的区别</a></li></ul></li><li><a href="#问题什么是死锁" class="table-of-contents__link toc-highlight">问题：什么是死锁</a></li><li><a href="#问题死锁产生的条件" class="table-of-contents__link toc-highlight">问题：死锁产生的条件</a></li><li><a href="#问题死锁的处理" class="table-of-contents__link toc-highlight">问题：死锁的处理</a></li><li><a href="#问题死锁的预防--避免" class="table-of-contents__link toc-highlight">问题：死锁的预防 / 避免</a><ul><li><a href="#死锁的预防" class="table-of-contents__link toc-highlight">死锁的预防</a></li><li><a href="#死锁的避免" class="table-of-contents__link toc-highlight">死锁的避免</a></li><li><a href="#银行家算法" class="table-of-contents__link toc-highlight">银行家算法</a></li></ul></li><li><a href="#问题死锁的检测--解除" class="table-of-contents__link toc-highlight">问题：死锁的检测 / 解除</a><ul><li><a href="#死锁的检测" class="table-of-contents__link toc-highlight">死锁的检测</a></li><li><a href="#死锁的解除" class="table-of-contents__link toc-highlight">死锁的解除</a></li></ul></li><li><a href="#问题并行--并发的区别" class="table-of-contents__link toc-highlight">问题：并行 / 并发的区别</a></li></ul></li><li><a href="#第三章内存管理" class="table-of-contents__link toc-highlight">第三章：内存管理</a><ul><li><a href="#问题内存管理的功能" class="table-of-contents__link toc-highlight">问题：内存管理的功能</a></li><li><a href="#问题内存的扩充" class="table-of-contents__link toc-highlight">问题：内存的扩充</a></li><li><a href="#问题内部碎片--外部碎片" class="table-of-contents__link toc-highlight">问题：内部碎片 / 外部碎片</a></li><li><a href="#问题内存的分配" class="table-of-contents__link toc-highlight">问题：内存的分配</a></li><li><a href="#问题内存的连续分配-3" class="table-of-contents__link toc-highlight">问题：内存的连续分配 (3)</a></li><li><a href="#问题动态分区分配算法" class="table-of-contents__link toc-highlight">问题：动态分区分配算法</a></li><li><a href="#问题解决内存中的碎片问题" class="table-of-contents__link toc-highlight">问题：解决内存中的碎片问题</a></li><li><a href="#问题内存的非连续分配" class="table-of-contents__link toc-highlight">问题：内存的非连续分配</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">分享</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/frontEnd/JavaScript">前端</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/code/algorithm">算法笔记</a></li><li class="footer__item"><a class="footer__link-item" href="/project">我的项目</a></li></ul></div><div class="col footer__col"><div class="footer__title">社交媒体</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/about">关于我</a></li><li class="footer__item"><a href="https://github.com/moxyNJ" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://juejin.cn/user/2005151873514024" target="_blank" rel="noopener noreferrer" class="footer__link-item">掘金<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Blog</div><ul class="footer__items"><li class="footer__item"><a href="https://www.ninjee.co" target="_blank" rel="noopener noreferrer" class="footer__link-item">Ninjee 的前端篮子</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright"><p>Copyright © 2022 Ninjee Built with Docusaurus.</p><p><a href="http://beian.miit.gov.cn/">晋ICP备2021017941号-2</a></p></div></div></div></footer></div>
<script src="/assets/js/runtime~main.cbc0f3f2.js"></script>
<script src="/assets/js/main.34499d57.js"></script>
</body>
</html>