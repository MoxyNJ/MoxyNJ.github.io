<!doctype html>
<html lang="zh" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-interview/summary/操作系统">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.18">
<link rel="alternate" type="application/rss+xml" href="/rss.xml" title="ninjee RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="ninjee Atom Feed">
<link rel="alternate" type="application/json" href="/feed.json" title="ninjee JSON Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Ninjee的前端篮子" href="/opensearch.xml">
<script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0930342e569f854bebdeb485c0eac7f8",e.defer=!0;var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>
<meta name="baidu-site-verification" content="code-rqLUw5reVS">
<link rel="icon" href="/img/ninjee.jpeg">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="rgb(51 139 255)"><title data-rh="true">操作系统 - Ninjee的前端篮子</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://ninjee.netlify.app/img/ninjee.jpeg"><meta data-rh="true" name="twitter:image" content="https://ninjee.netlify.app/img/ninjee.jpeg"><meta data-rh="true" property="og:url" content="https://ninjee.netlify.app/docs/interview/summary/操作系统"><meta data-rh="true" name="docusaurus_locale" content="zh"><meta data-rh="true" name="docsearch:language" content="zh"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="操作系统 - Ninjee的前端篮子"><meta data-rh="true" name="description" content="第一章：绪论"><meta data-rh="true" property="og:description" content="第一章：绪论"><meta data-rh="true" name="keywords" content="操作系统"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ninjee.netlify.app/docs/interview/summary/操作系统"><link data-rh="true" rel="alternate" href="https://ninjee.netlify.app/docs/interview/summary/操作系统" hreflang="zh"><link data-rh="true" rel="alternate" href="https://ninjee.netlify.app/docs/interview/summary/操作系统" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://AJRH2JRXVY-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.cb2f47c4.css">
<link rel="preload" href="/assets/js/runtime~main.6ad002de.js" as="script">
<link rel="preload" href="/assets/js/main.fe74e720.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/ninjee-icon.png" alt="ninjee" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/ninjee-icon.png" alt="ninjee" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Ninjee</b></a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">前端知识</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/frontEnd/JavaScript">JavaScript</a></li><li><a class="dropdown__link" href="/docs/frontEnd/HTML&amp;CSS">HTML &amp; CSS</a></li><li><a class="dropdown__link" href="/docs/frontEnd/React">React</a></li><li><a class="dropdown__link" href="/docs/frontEnd/浏览器原理">浏览器原理</a></li><li><a class="dropdown__link" href="/docs/frontEnd/other">other</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">敲代码</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/code/algorithm">算法</a></li><li><a class="dropdown__link" href="/docs/code/writtenJs">手写Js</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">面试</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/interview/summary">总结</a></li><li><a class="dropdown__link" href="/docs/interview/iot">物联网</a></li></ul></div><a class="navbar__item navbar__link" href="/project">我的项目</a><div class="toggle_S7eR colorModeToggle_vKtC"><button class="clean-btn toggleButton_rCf9 toggleButtonDisabled_Pu9x" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v35p"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_nQuB"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_qEbK"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="docPage_P2Lg"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_RiAD"><nav class="menu thin-scrollbar menu_izAj"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/javascript">JavaScript</a><button aria-label="打开/收起侧边栏菜单「JavaScript」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/html--css">HTML &amp; CSS</a><button aria-label="打开/收起侧边栏菜单「HTML &amp; CSS」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/react">React</a><button aria-label="打开/收起侧边栏菜单「React」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/浏览器原理">浏览器原理</a><button aria-label="打开/收起侧边栏菜单「浏览器原理」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/algorithm">algorithm</a><button aria-label="打开/收起侧边栏菜单「algorithm」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/手写-js">手写 Js</a><button aria-label="打开/收起侧边栏菜单「手写 Js」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/总结">总结</a><button aria-label="打开/收起侧边栏菜单「总结」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/summary">总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/summary/JavaScript">JavaScript相关</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/summary/浏览器">浏览器相关</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/summary/计算机网络">计算机网络</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/interview/summary/操作系统">操作系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/summary/HTML&amp;CSS">HTML&amp;CSS</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/summary/git">git</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/summary/React">React</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/summary/Typescript">Typescript</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/summary/webpack">Webpack</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/summary/Ajax&amp;Axios">Ajax、Axios</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/iot">Iot</a><button aria-label="打开/收起侧边栏菜单「Iot」" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/other">other</a><button aria-label="打开/收起侧边栏菜单「other」" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_FykI"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_DTRl"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Xlws" aria-label="breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/">🏠</a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/总结"><span itemprop="name">总结</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="item name">操作系统</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>操作系统</h1></header><h2 class="anchor anchorWithStickyNavbar_mojV" id="第一章绪论">第一章：绪论<a class="hash-link" href="#第一章绪论" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题什么是操作系统">问题：什么是操作系统<a class="hash-link" href="#问题什么是操作系统" title="标题的直接链接">​</a></h3><p>计算机的硬件、软件有一种层次关系。硬件在最底层，上层是操作系统，然后是安装的各种应用程序。操作系统是裸机上的第一层软件，是对硬件功能的首次扩充。</p><p>引入操作系统的目的是：</p><ol><li><strong>接口。</strong>提供一个计算机用户与计算机硬件系统之间的 <strong>接口</strong>；</li><li><strong>控制资源</strong>。有效地 <strong>控制和管理</strong> 计算机系统中的各种软件 / 硬件资源。</li><li><strong>工作流程</strong>。合理地组织计算机系统的 <strong>工作流程</strong>，以改善系统性能。</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题操作系统的功能和服务">问题：操作系统的功能和服务<a class="hash-link" href="#问题操作系统的功能和服务" title="标题的直接链接">​</a></h3><p>五大基本功能：处理器管理、存储器管理、设备管理、文件管理、用户接口。</p><ol><li><strong>处理器管理</strong>：处理器的分配和运行以 <strong>进程</strong> 为基本单位，对处理器管理就是对 <strong>进程的管理</strong><ul><li>进程控制：负责进程的创建、撤销、状态转换</li><li>进程同步：对并发执行的进程进行协调；</li><li>进程通信：负责完成进程间的信息交换</li><li>进程调度：按一定算法进行处理器分配（7）</li></ul></li><li><strong>存储器管理</strong>：对内存进行分配、保护、扩充。<ul><li>内存分配：按一定策略为每道程序分配内存；</li><li>内存保护：保证各程序在自己的区域内运行，而不相互干扰。</li><li>内存扩充：借助虚拟存储技术，获得增加内存的效果。</li></ul></li><li>设备管理：对计算机系统内的所有设备进行管理。<ul><li>设备分配：采用缓冲技术、虚拟技术，使设备与主机并行工作。</li><li>设备传输控制：实现物理 I/O，即启动设备、中断处理、结束处理等。</li><li>设备独立性：用户程序中的设备与实际使用的物理设备无关。</li></ul></li><li>文件管理：对文件系统的管理：<ul><li>文件存储空间管理：合理的分配与回收</li><li>目录管理：提供科学的数据结构，实现高效检索。</li><li>文件操作管理：完成文件的读写操作。</li><li>文件保护：解决文件的共享、保密、保护问题。</li></ul></li><li>用户接口<ul><li>命令接口：提供一组命令供用户控制自己的作业。</li><li>程序接口：也称 <strong>系统调用</strong>。用户可在程序中使用这组系统调用命令，向操作系统提出：使用外设、申请分配内存、磁盘文件读写等操作。</li><li>图形接口：也就是图形化命令接口。</li></ul></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题操作系统的发展--分类">问题：操作系统的发展 / 分类<a class="hash-link" href="#问题操作系统的发展--分类" title="标题的直接链接">​</a></h3><ol><li>手工阶段：纸带机。人机速度矛盾。</li><li>批处理阶段：<ul><li>单道批处理（脱机输入输出技术）<ul><li>缓解人机速度矛盾。资源利用率低没解决。</li></ul></li><li>多道批处理（操作系统雏形）<ul><li>提高资源利用率（多道程序并发执行）。没有人机交互。</li></ul></li></ul></li><li>分时操作系统（cpu 运行分时间片，任务轮流上 cpu 处理）<ul><li>提供人机交互。不能优先处理紧急任务。</li></ul></li><li>实时操作系统：<ul><li>硬实时系统（严格在规定时间内完成处理）</li><li>软实时系统（可偶尔违反时间限定）<ul><li>解决了优先处理紧急任务问题。</li></ul></li></ul></li><li>网络操作系统</li><li>分布式操作系统<ul><li>多个分散的处理单元，通过网络连接而成的系统。可以动态的分配任务。</li></ul></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题操作系统的运行环境--运行机制">问题：操作系统的运行环境 / 运行机制<a class="hash-link" href="#问题操作系统的运行环境--运行机制" title="标题的直接链接">​</a></h3><p>对处理器的执行状态，分为两种：</p><ul><li><strong>核心态</strong>：<strong>管态</strong>、<strong>系统态</strong>。操作系统管理程序执行时的状态。具有较高特权，能执行一切指令，能访问所有寄存器、存储区。</li><li><strong>用户态</strong>：<strong>目态</strong>。用户程序执行时机器的状态，权限较低。用户态程序不能直接调用核心态程序，而是通过执行访问核心态的命令，引起 <strong>中断</strong>，由中断系统转入操作系统内的相应程序。</li></ul><p>总结：<strong>用户进程在用户态工作、系统内核在内核态工作。</strong></p><p>特权指令：只能由操作系统内核使用，不允许用户直接使用。如 I/O 指令、设置中断屏蔽指令、清内存指令、存储保护指令、设置时钟指令。</p><p>操作系统的内核：内核指令在核心态工作。</p><ul><li>与硬件紧密的模块：时钟管理、 中断处理、设备驱动<ul><li>时钟管理：操作系统通过时钟管理，向用户提供标准的系统时间。通过时钟中断的管理，实现进程切换、时间片轮转调度。</li><li>中断机制：内核负责保护和恢复中断现场的信息。</li></ul></li><li>运行频率较高的程序：进程管理、存储器管理、设备管理。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题什么是中断--异常">问题：什么是中断 / 异常<a class="hash-link" href="#问题什么是中断--异常" title="标题的直接链接">​</a></h3><p>中断系统的作用：</p><ol><li>让操作系统的内核强行夺回 CPU 控制权；</li><li>使 CPU 从用户态变为内核态；</li></ol><p><strong>中断 / 外中断</strong></p><p>来源：中断信号来自 CPU <strong>外部</strong>，与当前指令无关。中断是在用户态触发的。</p><p>检查时机：CPU 在执行每个指令的周期末尾，CPU检查是否有外中断信号。</p><ul><li>时钟中断：时间片到期，需要切换应用进程。将正在执行的应用进程暂停，调用新进程</li><li>I/O 中断：用户进行 I/O 相关操作。正在执行的进程需等待用户输入，因而中断当前操作，等待资源到达。</li><li>硬件中断：硬件故障引起的中断，比如打印机突然没电</li><li>程序中断：程序在执行过程中的 <strong>一般中断</strong>。比如上文的 I/O 中断。</li></ul><p><strong>异常 / 内中断</strong></p><p>来源：中断信号来自 CPU 内部，与当先执行的指令相关。</p><p>检查时机：CPU 在执行指令时，随时检查是否有异常发生。</p><ul><li>陷阱 / 陷入 / trap：应用程序故意引发。</li><li>故障 / fault：进程的条件错误、条件不满足、CPU修复故障后继续。（缺页故障）</li><li>终止 / abort：致命错误，无法修复，终止进程。（整数除 0、非法使用特权指令）</li></ul><p><strong>通常异常会引起中断，而中断未必是异常引起。</strong></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题什么是系统调用">问题：什么是系统调用<a class="hash-link" href="#问题什么是系统调用" title="标题的直接链接">​</a></h3><p>系统调用是操作系统对应用程序/程序员提供的接口，API (Application Programming Interface)。</p><p>系统调用和中断在用户态发生，在核心态处理。</p><p>通过系统调用，可以把程序的请求传给内核，内核在完成相应的处理后，再返回给程序。</p><ul><li>用户进程在 <strong>用户态</strong>，通过 <strong>陷入</strong> 指令，执行系统调用，让进入操作系统的系统内核。</li><li>此时操作系统转化为 <strong>内核态</strong>。系统内核执行相应的 <strong>系统调用函数</strong>，然后将处理结果返回给用户进程。</li><li>此时操作系统再切换为 <strong>用户态</strong>，用户进程拿到结果，程序继续运行。</li></ul><p>系统调用的功能有：</p><ul><li>进程管理、文件操作、设备管理、主存管理、进程通信、信息维护。</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="第二章进程管理">第二章：进程管理<a class="hash-link" href="#第二章进程管理" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题什么是进程">问题：什么是进程<a class="hash-link" href="#问题什么是进程" title="标题的直接链接">​</a></h3><p><strong>是系统进行资源分配、运行调度的基本单位。</strong></p><p>通过进程、程序来定义进程：</p><p>程序：静态（静止的有序代码）、永久（在外存中存放）、一个程序可以产生多个进程。</p><p>进程：动态（在执行中的程序）、暂时（在内存中运行）、一个进程可以调用多个程序。</p><p>通过引入进程的原因来定义进程：</p><ul><li>下一个问题</li></ul><p>从进程的 5 特征来定义进程：</p><ol><li>动态性。最基本特性，执行的过程是动态可控、可调整的。</li><li>并发性。多个进程可同时存在内存中，可同时运行。</li><li>独立性。进程是独立运行、资源分配和调度的基本单位。</li><li>异步性。各个进程的各自独立、不可预知的速度推进。</li><li>结构性。每个进程：PCB + 程序段 + 数据段组成。<ul><li>PCB 进程控制块：唯一标识进程、存储控制信息、资源分配信息等。</li><li>程序段：程序的指令代码。</li><li>数据段：运行中需要的、产生的数据。</li></ul></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题为什么引入进程">问题：为什么引入进程<a class="hash-link" href="#问题为什么引入进程" title="标题的直接链接">​</a></h3><p>程序的执行是顺序的，具有 3 个特性：</p><ul><li>顺序性：处理器的操作严格按照程序的规定顺序执行。完成当前操作才做下一个操作。</li><li>封闭性：程序一旦开始运行，独占系统的所需资源，这些资源只有本程序才能改变。</li><li>可再现性：程序执行时的初始条件、执行环境相同，重复执行时，结果一定相同。</li></ul><p>当操作系统引入 <strong>并发</strong>：</p><p>程序的并发执行：若干程序同时在系统中运行，这些程序的执行在时间上是重叠的，即一个程序的执行尚未结束，另一个程序的执行已经开始。</p><ul><li>优点：提高系统的处理能力和资源利用率。<ul><li>可以合理的分配： I/O 资源、网络资源、CPU 处理资源、磁盘读写资源等。</li></ul></li></ul><p>这导致了程序失去了特性：</p><ul><li><strong>间断性</strong>。程序在并发执行时，相互是制约关系，在资源共享时，程序常间断执行。</li><li><strong>失去封闭性</strong>。程序在执行时，必然受到其他程序的影响，资源不是独立占据并使用的。</li><li><strong>不可再现性</strong>。程序并发执行时，失去了封闭性，每次执行环境不同，结果也可能不同。</li></ul><p>当操作系统引入 <strong>进程</strong>：</p><p>为了使程序在并发时保持封闭性和可再现性，需要对资源共享进行更合理的调配。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题进程的状态与转换">问题：进程的状态与转换<a class="hash-link" href="#问题进程的状态与转换" title="标题的直接链接">​</a></h3><p> 5 + 2 种状态：</p><ul><li><p>正常流程：创建态 ➡️ 就绪态 ➡️ 运行态 ➡️ 终止态；</p></li><li><p>发生阻塞：阻塞态；</p></li><li><p>两个挂起：阻塞挂起、就绪挂起；</p></li></ul><p>创建态：进程正在创建的状态。创建 PCB，填入信息 ➡️ 分配需要的资源。</p><p>就绪态：进程已经获得除 CPU 以外的所有资源，一旦获得 cpu 资源，就可以立即执行。</p><p>执行态 / 运行态：进程在 cpu 上执行时的状态。</p><p>阻塞态 / 等待态：进程因发生事件而 <strong>暂停</strong>，无法执行的状态。通常在等待资源。</p><p>终止态 / 结束态：回收进程的资源 ➡️ 撤销 PCB。正常执行完毕，也有可能异常退出。</p><p>挂起：排队的过程。从内存调入外存。进程映像放在外存中。</p><p>5 状态模型：</p><p><img loading="lazy" alt="截屏2022-08-12 18.53.00" src="/assets/images/截屏2022-08-12 18.53.00-ef93c1a8146719db9b6cdadbf3383041.png" width="2300" height="964" class="img_E7b_"></p><p>7 状态模型</p><p><img loading="lazy" alt="截屏2022-08-12 18.51.39" src="/assets/images/截屏2022-08-12 18.51.39-d2bbaa79a179999107f239485de14949.png" width="1262" height="596" class="img_E7b_"></p><p>总结：</p><p><strong>执行态</strong> 可以切换到：</p><ul><li>阻塞状态：是因为请求并等待事件发生</li><li>就绪状态：是因为时机片用完、抢占式调度中有优先级任务需要执行。</li><li>终止状态：进程执行完毕、异常中断，需要销毁。</li></ul><p>只有 <strong>就绪态</strong>，可以切换到 <strong>执行态</strong>。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题-进程的控制进程的通信线程的通信">问题：🌟 进程的控制/进程的通信/线程的通信<a class="hash-link" href="#问题-进程的控制进程的通信线程的通信" title="标题的直接链接">​</a></h3><p><strong>💊 进程的控制</strong></p><p>概念：实现进程的创建、状态转换。通过 <strong>原语</strong> 实现控制，本质是关 / 开中断实现。</p><p>原语的工作：</p><ol><li><strong>进程的状态切换。</strong>更新 PCB 信息（修改进程运行状态、保存/恢复进程运行环境）；</li><li><strong>进程的阻塞 / 唤醒。</strong>将 PCB 插入合适队列（就绪、阻塞等）；</li><li><strong>进程的创建 / 撤销。</strong>分配 / 回收资源（进程是否撤出/放入内存）；</li></ol><p>原语的内容：</p><ul><li>阻塞原语：P原语。进程 <strong>主动调用</strong>，并切换。（运行 ➡️ 阻塞）</li><li>唤醒原语：V原语。进程被动切换。（阻塞 ➡️ 就绪）</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="-进程间的通信">🌟 进程间的通信<a class="hash-link" href="#-进程间的通信" title="标题的直接链接">​</a></h4><p>低级通信方式</p><ul><li><p>锁机制</p><ul><li>进程要更改共享数据时，先锁定资源，独占访问权。直到访问完毕后解锁，其他的进程才能再次锁定该资源。互斥锁保证每次只有一个进程进行写入操作，从而保证多线程情况下数据的正确性。</li></ul></li><li><p>P 原语、V 原语（信号量）：实现进程的同步、互斥</p></li></ul><p>高级通信方式</p><ol><li><p>共享存储</p><ul><li>一个互斥访问的共享存储区。</li></ul></li><li><p>管道通信</p><ul><li>管道为一个共享的、互斥访问的特殊共享文件。</li><li>一个管道：半双工通信。两个管道：全双工。</li><li>管道中必须全满 / 全空，才可以继续操作（读/写）。</li></ul></li><li><p>消息传递</p><ul><li>消息为单位通信（消息头/消息尾）。通过系统的 ‘发送/接受原语’ 实现。</li><li>直接通信方式：直接挂到接收方的消息队列中</li><li>间接通信方式（信箱）：通过信箱中间体。</li></ul></li><li><p>socket</p><ul><li>它可用于不同机器间的进程通信</li></ul></li></ol><h4 class="anchor anchorWithStickyNavbar_mojV" id="-线程间的通信">🌟 线程间的通信<a class="hash-link" href="#-线程间的通信" title="标题的直接链接">​</a></h4><ol><li><p>锁机制</p><ul><li>某线程要更改共享数据时，先锁定资源，独占访问权。直到访问完毕后解锁，其他的线程才能再次锁定该资源。互斥锁保证每次只有一个线程进行写入操作，从而保证多线程情况下数据的正确性。</li></ul></li><li><p>P 原语、V 原语（信号量）：实现线程的同步、互斥</p><ul><li>信号量：资源统计 + 等待队列。通过原语的 开、关 中断，一气呵成，实现上锁🔒的不可被打断。</li></ul></li><li><p>Java中有一些包支持线程间通信：Condition 条件对象、event 事件对象。</p></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题-为什么要引入线程">问题：🌟 为什么要引入线程<a class="hash-link" href="#问题-为什么要引入线程" title="标题的直接链接">​</a></h3><p><strong>区分：线程是 CPU 调度的基本单位、进程是资源分配的基本单位。</strong></p><p>进程的特点：</p><ul><li>进程是一个用有资源的独立单元</li><li>进程同时又是一个可以被处理器独立调度和分配的单元。</li></ul><p>存在的缺点：</p><ul><li>操作系统还需要进行：进程创建、撤销、状态切换。进行这些操作时，需要为进程分配资源和回收资源，同时要保存进程现场信息，付出了较大时空开销。</li></ul><p>解决思路：</p><ul><li>在系统中尽量少的创建进程、尽量低频的切换进程。</li></ul><p>解决方式：</p><ul><li>将进程的两个特点切分，让进程只完成第一个任务：资源独立的单元，线程去完成第二个任务：CPU 调度的基本单位。</li></ul><p>总结：</p><p>引入进程的目的，是让多个程序可以并发执行，以改善资源利用率，提高系统吞吐量。</p><p>引入线程的目的，是减少程序并发执行时所付出的时空开销，使操作系统更好的并发性。</p><ul><li>线程是进程内相对独立的、可调度的执行单元。线程自己基本不拥有资源，只在运行时占用一点资源（程序计时器、寄存器、栈），同一个进程内的资源，线程相互共享。</li></ul><p>同一进程内的线程：</p><ol><li>内存地址共享。</li><li>资源共享。</li><li>线程间的通信无需经过操作系统。</li><li>线程的切换，不会倒车进程的切换。</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题线程的实现">问题：线程的实现<a class="hash-link" href="#问题线程的实现" title="标题的直接链接">​</a></h3><p><strong>用户级线程</strong>：不需要操作系统。进程通过线程库控制线程。</p><ul><li>优：线程调度不需要用户态 / 内核态切换。速度极快。</li><li>缺：一个线程阻塞，整个进程等待（时间片是分配给进程的，CPU看不到线程，不知道阻塞，不会切换线程）</li></ul><p><strong>内核级线程</strong>：操作系统实现线程，完成线程的创建和销毁工作。</p><ul><li>优：一个线程阻塞由于 IO 阻塞时，不影响其他线程运行（时间片是分配给线程的，CPU 可以感知到阻塞，然后主动切换）</li><li>缺：切换速度慢，依赖内核态。</li></ul><p><strong>两种组合</strong>：用户、内核都可以建立线程，各取优点。</p><ul><li>一对一：一个用户级线程，映射，一个内核级线程<ul><li>优：并发度高。线程都可以分配到CPU并发执行。</li><li>缺：开销大。操作系统管理线程太多。</li></ul></li><li>一对多：多个用户级线程，映射，一个内核级线程<ul><li>优：开销小。管理高效。</li><li>缺：并发度低。若一个线程阻塞，则无法调度其他线程，整个进程阻塞。</li></ul></li><li>多对多：开销小，并发度高</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题处理器的三级调度">问题：处理器的三级调度<a class="hash-link" href="#问题处理器的三级调度" title="标题的直接链接">​</a></h3><p>调度是操作系统的基本功能。CPU 是计算机的首要资源，所以调度设计均围绕如何高效利用 CPU 资源而展开。异构作业从提交到执行，通常要经历多级调度。</p><ul><li>高级调度（作业）：在队列中挑选一个作业，外存进内存，添加资源 + 创建进程。<ul><li>无  ==&gt;  创建态  ==&gt;  就绪态</li></ul></li><li>中级调度（内存）：队列中，外存进内存，挂起变就绪。<ul><li>挂起就绪态  ==&gt;  就绪态</li><li>挂起阻塞态  ==&gt;  阻塞态</li></ul></li><li>低级调度（进程）：队列中，内存进 CPU。<ul><li>就绪态  ==&gt;  运行态</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题-调度算法-7">问题：🌟 调度算法 (7)<a class="hash-link" href="#问题-调度算法-7" title="标题的直接链接">​</a></h3><p>进程的调度策略</p><p><strong>💊 进程调度的时机</strong></p><ul><li>进程主动放弃<ul><li>进程执行完毕，终止进程。</li><li>进程主动阻塞，等待所缺资源，如 I/O 操作、网络资源。</li></ul></li><li>进程被动放弃<ul><li>时间片用尽。</li><li>CPU 被抢占，高优先级进程在就绪态。</li><li>紧急事件处理，如 I/O中断，杀进程。</li></ul></li></ul><p>抢占式：如果有高优先级进程进入就绪态，就会让正在处理的进程挂起。</p><p>非抢占式：不会让正在处理的进程挂起，而是等待执行完成，或主动进入阻塞态时，再执行。</p><p><strong>💊 批处理系统 (3)</strong></p><p>先来先服务 FCFS（作业调度、进程调度）</p><ul><li><p>按照队列的思路，先排队的先执行，没有优先级概念。</p><ul><li><p>优：公开、实现简单。进程不会饥饿。</p></li><li><p>缺：对长作业有利，短作业不利。短作业周转时间长，等待的时间过多。</p></li></ul></li></ul><p>短作业优先 SJF（非抢占）（作业调度、进程调度）</p><ul><li><p>在挂起就绪的队列中，周期性评估可以最短完成的作业，然后优先让它们执行。</p><ul><li><p>优：平均等待时间、平均周转时间最短。</p></li><li><p>缺：长作业不利，会饥饿</p></li></ul></li></ul><p>高响应比优先 HRRN（ only 作业调度）</p><p>综合了任务的等待时间和预估运行时间，形成相应比公式。</p><ul><li><p>响应比 =（等待时间 + 预估运行时间）/ 预估运行时间  &gt;= 1</p></li><li><p>优：综合优点：综合短作业优先（预估运行时间）、先来先服务（等待时间）
避免缺点：防止长作业饥饿（等待时间长，则优先服务）。</p></li><li><p>缺：响应比的计算需要开销。</p></li></ul><p><strong>💊 实时操作系统 (4)</strong></p><p>时间片轮转（抢占）（only 进程调度）</p><p>所有进程按照先来先服务进入队列，CPU 资源按照时间片划分，到时间后就挂起当前的进程，切换下一个进程进场使用 CPU 资源。</p><ul><li><p>优：公平、响应快、适用于分时操作系统。所有进程都不会饥饿。</p></li><li><p>缺：进程切换频率高，状态切换需要开销。不能区分任务的紧急程度。</p></li></ul><p>优先级调度（抢占 / 非抢占）（作业调度、进程调度）</p><ul><li><p>根据系统需求，可以对任务进行优先级划分。然后高优任务先执行。</p><ul><li><p>优：区分紧急程度，适用于实施操作系统。灵活调整优先级偏好。</p></li><li><p>缺：高优先级过多，低优先级的进程就会饥饿。</p></li></ul></li></ul><p>多级队列调度（非抢占）（进程调度）</p><ul><li>将等候的进程划分多个队列，每个队列都采用各自的调度算法。</li></ul><p>多级反馈队列调度（抢占）（进程调度）</p><ul><li><p>多级队列：依然划分多个队列，每个队列优先级从高到低，时间片从小到大。</p></li><li><p>每个队列：队列内统一按照 <strong>先来先服务</strong>。</p></li><li><p>当新进程进入调度时，首先放入第一个队列（高优 + 短时）的队尾，等待执行。如果在划分好的时间片内没有执行完毕，则重新放入第二个队列的队尾。以此类推。最后一个队列无法再往下分，则使用 <strong>时间片轮转调度算法</strong>。</p><ul><li><p>优：公平（先来先服务），新进程快速响应（高响应比优先），短进程快速处理（多作业优先），灵活偏好（优先级）</p></li><li><p>缺：会饥饿（如果第一个队列没执行完，会一直运行第一个队列的进程）</p></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题-进程的同步--互斥">问题：🌟 进程的同步 / 互斥<a class="hash-link" href="#问题-进程的同步--互斥" title="标题的直接链接">​</a></h3><p>同步和互斥的区别：</p><ul><li><p>同步，直接相互制约：有先后次序的需求，不同类型的进程。 </p></li><li><p>互斥，间接相互制约：有争用资源的需求，相同类型的进程。 </p></li></ul><p><strong>同类进程即为互斥关系、不同类进程即为同步关系。</strong></p><ul><li>消费者和生产者就是同步关系、消费者和消费者就是互斥关系。</li></ul><p>互斥存在临界资源：</p><ul><li>临界资源：同时只允许一个进程使用的资源。入打印机、绘图机等。</li></ul><p>访问临界资源的过程：</p><p>进入区：检查是否可进入，上锁🔒的代码，对即将进入的进程添加访问标记。</p><p>临界区：临街段，进程中访问临界资源的代码。</p><p>退出区：解锁🔓的代码，对访问结束的进程删除访问标记。</p><p>剩余区：其余代码，进程中除上述 3 部分以外的代码。</p><p><img loading="lazy" alt="临界区互斥-来源参考[3]" src="/assets/images/1fa1353e587e4fe8ab0967538699492d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0-e7ff4a20fd3ccd76d8c424bf5ea5c27a.awebp" width="929" height="471" class="img_E7b_"></p><p>互斥的原则（4）</p><ul><li>空闲让进：临界区空闲，则允许进程访问。</li><li>忙则等待：临界区占用，则禁止其他进程访问。</li><li>有限等待：不会饥饿，有限时间内，一定会进入临界区。</li><li>让权等待：不满足条件的进程，不会盲等，占用CPU资源。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题-互斥的实现锁">问题：🌟 互斥的实现（锁）<a class="hash-link" href="#问题-互斥的实现锁" title="标题的直接链接">​</a></h3><p>有 4 + 2 种方式：核心思想就是如何 <strong>加锁</strong>。</p><p><strong>软件方式</strong></p><div class="codeBlockContainer_I0IT language-typescript theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-typescript codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 单标志法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 公用 turn 标志进程号。谁先进去，谁就修改一下 turn。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 缺：进入时只检查，不上锁。退出时给对方解锁，给自己上锁（转交使用权）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 不满足：空闲让进。必须进程交替进入。</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>双标志先检查法<ul><li>数组 flag<!-- -->[ false, false ]<!-- -->。先检查，后上锁🔒。进程只修改自己的标志。</li><li>缺：检查和上锁无法一气呵成。</li><li>优：解决空闲让进。不需要交替进入</li><li>不满足：忙则等待。若同时检查通过，会同时进入。</li></ul></li><li>双标志后检查法<ul><li>数组 flag<!-- -->[  ]<!-- -->。先上锁🔒，后检查。进程只修改自己的标志。</li><li>缺：检查和上锁无法一气呵成。</li><li>优：解决忙则等待。先上锁确保不会同时进入。</li><li>不满足：空闲让进 + 有限等待。同时上锁，都进不去，产生饥饿。</li></ul></li><li>Peterson 算法（皮特森算法）<ul><li>算法 1 和 3 的结合。flag<!-- -->[false, false ]<!-- --> = 希望进入；turn = 谦让。<ul><li>利用 flag[] 解决资源互斥访问、利用 turn 解决进程饥饿。比如 p0 进程想要读区资源，会把自己位置的 flag<!-- -->[0]<!-- --> 置为 true，然后把 ture = 1 谦让对方先执行。接下来判断：<code>while(flag[1] &amp;&amp; turn = 1)</code> 就一直等待。直到 p1 的 flag 位置调整为 false，或 turn 指向自己 0。<ul><li>flag<!-- -->[1]<!-- --> 为真表示 p1 希望访问，turn 为 1 表示 p1 可以访问。</li></ul></li></ul></li><li>进入区：表明想用 ➡️ 主动谦让 ➡️ 检查（对方是否想进，我是否谦让）</li><li>检查：对方想进 且 我主动谦让，则循环等待。 while ( flag<!-- -->[1]<!-- -->=true &amp;&amp; turn==1 )</li><li>优：综合上面三种方法，解决：空闲让进、忙则等待、有限等待。</li><li>缺：不满足让权等待（四个方法都不满足）一直占用 CPU。</li></ul></li></ul><p><strong>硬件方式</strong></p><div class="codeBlockContainer_I0IT language-typescript theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-typescript codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 中断屏蔽法 和 硬件指令法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 开</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">关中断指令，利用 </span><span class="token operator" style="color:#393A34">**</span><span class="token plain">原语</span><span class="token operator" style="color:#393A34">**</span><span class="token plain">，确保检查和上锁一气呵成，不被打断。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 优：简单、易于实现。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> 缺：</span><span class="token keyword control-flow" style="color:#00009f">while</span><span class="token plain"> 一直循环等待，违背让权等待，产生饥饿。</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题信号量">问题：信号量<a class="hash-link" href="#问题信号量" title="标题的直接链接">​</a></h3><p><strong>引入信号量：</strong></p><p>解决进程互斥，上述提到了 6 种方式。软件方法存在算法复杂、效率不高、违背 <strong>忙则等待</strong> 原则的问题；硬件方法存在违背 <strong>让权等待</strong> 的缺点。</p><p>信号量是一种同步机构，一种协调进程间共享资源访问的⽅法。</p><ul><li>解决了让权等待，忙则等待，不会浪费 CPU 资源。</li></ul><p>解决方式：通过原语的 开、关 中断，一气呵成，实现上锁🔒的不可被打断。</p><div class="codeBlockContainer_I0IT language-js theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-js codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// semaphore 信号量 = 资源数量统计 + 等待队列</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> s </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">count</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">10</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">queue</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// P 操作：🔒 + 申请 / 使用资源</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token function-variable function" style="color:#d73a49">wait</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">p</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">count</span><span class="token operator" style="color:#393A34">--</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">s</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">count </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block 原语  </span><span class="token comment" style="color:#999988;font-style:italic">// 阻塞该进程: 进程挂起到阻塞队列</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">queue</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">unshift</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">p</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 将该 p 进程插入等待队列 s.queue</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// p进程使用资源</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// V 操作：🔓 + 释放/ 产生资源</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token function-variable function" style="color:#d73a49">signal</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">p</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  s</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">count</span><span class="token operator" style="color:#393A34">++</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">s</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">count </span><span class="token operator" style="color:#393A34">&gt;=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">queue</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">pop</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 队列中取出最后一个进程p</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    weakup 原语 </span><span class="token comment" style="color:#999988;font-style:italic">// 将p放入就绪队列，等待执行</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><strong>信号量的使用</strong></p><p>实现进程同步：先 V 后 P。</p><ul><li>初始资源值为 0。先生产资源、再消费资源。</li></ul><p>举例：P1 中有语句 S1，P2 中有语句 S2。要求 S1 必须在 S2 之前执行。</p><div class="codeBlockContainer_I0IT language-js theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-js codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// 设置信号量初始值</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">semaphore</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">count </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">P1</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">S1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">V</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">count</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">P2</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">P</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">count</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">S2</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>实现进程互斥：先 P 后 V</p><ul><li>初始资源值为 1。先执行的进程，优先消费资源，后执行的进程只能等待。</li></ul><div class="codeBlockContainer_I0IT language-js theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-js codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// 设置信号量初始值</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">semaphore</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">count </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">P1</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">P</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">count</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// P1 的临界代码</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">V</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">count</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">P2</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">P</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">count</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// P2 的临界代码</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token constant" style="color:#36acaa">V</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">count</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="死锁饥饿活锁死循环的区别">死锁、饥饿、活锁、死循环的区别<a class="hash-link" href="#死锁饥饿活锁死循环的区别" title="标题的直接链接">​</a></h3><ul><li>死锁：(<strong>争用公共资源</strong>) 多个进程之间，相互竞争资源，陷入无期限地等待其他进程占有的资源，都在阻塞等待。</li><li>饥饿：(<strong>优先级问题</strong>) 某一个进程，因任务调度问题，长期得不到资源而阻塞。(短作业优先) 如果长期无法执行，该进程则处在 <strong>饿死</strong> 状态。</li><li>活锁：在忙时等待条件下发生的饥饿，称之为“活锁”。例如不公平的互斥算法，让某些进程一直在等待被占用的资源，这实际上也是优先级的问题。</li><li>死循环：某一个进程，在 while、for 等逻辑内，跳不出循环。(P V 操作)</li></ul><p><strong>💊 死锁 / 饿死的区别</strong></p><p>共同点：死锁 / 饿死都是因 <strong>竞争资源</strong> 而引起的。</p><p>不同点：</p><p>从所争资源考虑：</p><ul><li>死锁：死锁进程等待的是永远也不会释放的资源。</li><li>饿死：饿死进程等待的是会释放、但永远也不会分配给自己的资源。</li></ul><p>从进程状态考虑：</p><ul><li>死锁：一定发生了循环等待 (哲学家困境)，可以通过资源分配图检测出。</li><li>饿死：没有循环等待，无法通过资源分配图检测。</li></ul><p>从涉事人员考虑：</p><ul><li>死锁：一定是两个以上的进程，都发生了死锁。</li><li>饿死：一个进程就可能被饿死。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题什么是死锁">问题：什么是死锁<a class="hash-link" href="#问题什么是死锁" title="标题的直接链接">​</a></h3><p>通过 <strong>哲学家问题</strong> 引发的死锁。</p><ul><li>5 个哲学家围坐一张桌子。桌子上有 5 根筷子，分别放在每个哲学家之间。哲学家的动作有：思考、进餐两种。进餐时需要同时拿起左右手的两根筷子，思考时需要将左右手的筷子放回原处。</li><li>这就是并发进程执行时，处理临界问题面临的困局。筷子是临界资源，不能被两个哲学家一起使用，仅此用一个信号量数组来表示筷子。</li><li>死锁僵局：当 5 个哲学家同时饥饿而各自拿左边的筷子时，会导致 5 根筷子均被占用，当他们要拿右手筷子时，会因没有筷子而无限等待，但是又不愿放弃左手的筷子，这就是所谓 <strong>让权等待</strong> 原则。</li></ul><p>解决方式：规定奇数号的哲学家先拿左边筷子，然后拿右边筷子；偶数号的哲学家相反。</p><p>定义：当多个进程因竞争系统资源或相互通信，而处于永久阻塞状态。若无外力作用，僵局无法打破，这些进程都会陷入无期限地等待其他进程占有的、自己无法得到的资源。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题死锁产生的条件">问题：死锁产生的条件<a class="hash-link" href="#问题死锁产生的条件" title="标题的直接链接">​</a></h3><p>围绕资源，死锁产生的原因有两点：<strong>系统资源不足</strong> (根本原因)、<strong>进程推进顺序不当</strong>。</p><p><strong>死锁产生必须满足 4 个条件</strong>：</p><ul><li><strong>互斥条件</strong>：进程间的资源必须互斥。一段时间内某种资源仅为一个进程所占有。</li><li><strong>不剥夺条件</strong>：进程掌握的资源无法强制剥夺收回，只能由进程使用完后，主动释放。</li><li><strong>请求和保持条件</strong>： 进程已经申请到一部分资源，在等待分配其他需求资源的同时，继续占有已经分配到的资源，不释放。</li><li><strong>环路等待条件</strong>：进程间发生了循环等待链条，也就是哲学家困境。需要的资源被其他进程持有，这样形成了一个资源的循环等待链。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题死锁的处理">问题：死锁的处理<a class="hash-link" href="#问题死锁的处理" title="标题的直接链接">​</a></h3><p>主要有 4 种思路：</p><ul><li>不处理：鸵鸟算法。</li><li>预防死锁：静态处理，预先破坏产生死锁的 4 条件中的某些条件。</li><li>避免死锁：动态处理，在分配资源过程中，用算法（银行家算法），防止发生死锁。</li><li>死锁的检测和解除：发生死锁后解决。通过系统检测，及时发现死锁，然后解决。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题死锁的预防--避免">问题：死锁的预防 / 避免<a class="hash-link" href="#问题死锁的预防--避免" title="标题的直接链接">​</a></h3><p><strong>预防死锁</strong> 和 <strong>避免死锁</strong> 是不一样的：</p><ul><li>两种都在死锁产生之前，实施措施，不同的是：</li><li><strong>死锁预防</strong> 是非常严格的，通常会对系统并发性造成很大副作用，同时也不需要再添加额外的算法去避免死锁。</li><li><strong>死锁避免</strong> 对系统附加条件相关宽松，有利于并发，但在资源被分配出去之前要计算分配之后系统是否安全，有额外的算法开销。</li></ul><p><strong>💊 死锁的预防</strong></p><p>只需破坏产生死锁的 4 个必要条件之一即可：</p><ul><li>破坏互斥：<ul><li>让资源不再互斥：临界资源改为共享资源（SPOOLing技术）</li><li>缺点：有些资源（🖨️）无法变为共享资源，可行性低。</li></ul></li><li>破坏不可剥夺：<ul><li>当进程已经获得一部分资源，而剩余资源无法满足时，有两种思路：<ol><li>强制释放自己的所有资源；</li><li>按照优先级，剥夺别人的资源（优先级）。</li></ol></li><li>缺：算法开销大，有些进程会饥饿，被随意剥夺资源可能会造成严重后果。</li></ul></li><li>破坏请求和保持：<ul><li>静态分配的办法，进程一次性申请全部所需资源，预先分配好全部资源，才运行</li><li>缺：资源利用率低，有些进程迟迟得不到资源，会饥饿。</li></ul></li><li>破坏循环等待：<ul><li>有序资源分配。资源按不同类型编号；进程申请资源必须从小到大，有序申请。</li><li>比如给打印机为1，磁带机为2，进程必须从1到2申请，不能反着申请。</li><li>缺：不便于新增设备，资源利用率低，编程困难。</li></ul></li></ul><p><strong>💊 死锁的避免</strong></p><p>动态方法：在系统进行资源分配前，先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则分配，否则不分配，进程继续等待。</p><ul><li>安全状态：系统不会死锁，则该序列为安全序列。</li><li>不安全状态：系统不稳定，有可能会死锁，也有可能会回到安全状态。</li><li>安全性算法：寻找安全序列 —— 银行家算法 🏦</li></ul><p><strong>💊 银行家算法</strong></p><blockquote><p><a href="https://www.bilibili.com/video/BV1Nx411X7hT?spm_id_from=333.337.search-card.all.click&amp;vd_source=591709e27d352a97b88a4c9ec8b2ad39" target="_blank" rel="noopener noreferrer">🔗</a></p></blockquote><p>通过多个进程资源分配表：</p><table><thead><tr><th>进程最大需求量</th><th>已经分配量</th><th>还需要的量</th><th>系统剩余资源</th><th>申请的量</th></tr></thead><tbody><tr><td>max</td><td>Allocation</td><td>Need</td><td>Available</td><td>Reques</td></tr></tbody></table><p>步骤：</p><div class="codeBlockContainer_I0IT language-typescript theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-typescript codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token number" style="color:#36acaa">1.</span><span class="token plain"> 检查申请是否超过这个进程之前申请的最大需求量；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">1.</span><span class="token plain"> 检查系统剩余可用资源是否满足；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">1.</span><span class="token plain"> 模拟分配，使用安全性算法，寻找安全序列（就是资源先给谁，后给谁）</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题死锁的检测--解除">问题：死锁的检测 / 解除<a class="hash-link" href="#问题死锁的检测--解除" title="标题的直接链接">​</a></h3><p><strong>💊 死锁的检测</strong></p><p>数据结构：资源分配图 (有向图)</p><ul><li>两种结点：进程结点(一个进程)、资源结点(一类资源，有数量)</li><li>两种边：申请边、分配边</li></ul><p>检测方式：</p><ol><li>找到可能形成孤立的、 不阻塞的进程结点，即它已经获得了所有所需资源，可以继续运行知道进程执行完毕，然后释放持有资源。</li><li>假设该可能孤立的进程释放资源后，消除其持有资源的边，简化资源分配图。</li><li>重复这一过程，直到不可再简化：<ul><li>若能消除所有边 ➡️ 可完全简化的，没有死锁</li><li>不能消除所有边 ➡️ 发生死锁</li></ul></li></ol><p><strong>💊 死锁的解除</strong></p><p>资源剥夺法：从其他进程中抢占所需资源，挂起这些进程，让自己解除死锁状态。</p><p>撤销进程法：终止某些进程，让它们归还占用资源，然后分配给其他进程，解除死锁状态。</p><p>进程回退法：让一些进程回退到系统不死锁的状态，进程自愿释放资源，而不是剥夺。这要求系统保持进程的历史信息，设置还原点。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题并行--并发的区别">问题：并行 / 并发的区别<a class="hash-link" href="#问题并行--并发的区别" title="标题的直接链接">​</a></h3><p>并发：一条赛道，同步执行。并发是单核 CPU 的一种调度算法。通过时间片轮转，给不同的进程都有公平参与执行的机会，不会导致进程饿死。因切换速度足够快，宏观上看似多个进程在同时执行。</p><p>并行：多条赛道，同时执行。就是多核 CPU，可以各自管理，真正的同时执行多个进程。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="第三章内存管理">第三章：内存管理<a class="hash-link" href="#第三章内存管理" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题内存管理的功能">问题：内存管理的功能<a class="hash-link" href="#问题内存管理的功能" title="标题的直接链接">​</a></h3><ol><li>内存空间分配 / 回收：连续 / 非连续 分配。</li><li>扩充内存：对内存空间的扩充，采用 覆盖、交换、虚拟 等方式。</li><li>地址变换：相互转换：程序中使用的逻辑地址，和内存中实际的物理地址</li><li>内存保护：(两种寄存器) 保证不同作业互不干扰，防止作业 A 发生错误而破坏作业 B</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题内部碎片--外部碎片">问题：内部碎片 / 外部碎片<a class="hash-link" href="#问题内部碎片--外部碎片" title="标题的直接链接">​</a></h3><p>内部碎片：已经分配给作业，但不能被作业利用的内存空间。</p><p>外部碎片：还没有分配给作业，但由于碎片太小而无法分配给作业的内存空间。</p><p>通俗说，作业占用的内存空间，没有装满，有剩余就是内部碎片。有些内存区域无法分配给作业，就是外部碎片。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题内存的分配方法">问题：内存的分配方法<a class="hash-link" href="#问题内存的分配方法" title="标题的直接链接">​</a></h3><p>内存的空间分配与回收，分为 3 个思路：</p><ul><li><strong>连续分配</strong> 3 ：<ul><li>单一连续分配</li><li>固定分区分配</li><li>动态分区分配</li></ul></li><li><strong>非连续分配</strong> 3：内存可连续（分页）、可离散（分段）<ul><li>基本分页存储管理：基本、快表、二级页表</li><li>基本分段存储管理</li><li>基本段页式存储管理</li></ul></li><li><strong>虚拟内存技术</strong><ul><li>请求分页存储管理</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题内存的连续分配-3">问题：内存的连续分配 (3)<a class="hash-link" href="#问题内存的连续分配-3" title="标题的直接链接">​</a></h3><p><strong>单一连续分配</strong> (单道程序)</p><p>最简单的分配方式，系统区是内存低地址部分，给系统使用。</p><ul><li>内存分为：系统区 + 用户区。</li><li>只支持一个程序进入，静态分配，采用覆盖技术扩充内存。</li><li>优：管理简单，无外部碎片。</li><li>缺：单用户、单操作系统，有内部碎片。</li></ul><p><strong>固定分区分配</strong> (多道程序)</p><p>内存事先划分大小不等的固定区域，在运行时不能更改。每个分区可以装入一道程序。</p><ul><li>内存划分：系统区 + 大小不一 (相等) 的固定分区，不再更改。</li><li>设置分区说明表：分区号(隐含)、容量、起始地址、状态(是否分配)。</li><li>程序装入时：找到合适大小的分区装入，不满足则拒绝装入，装入采用静态重定位方式</li><li>优：支持多道程序，无外部碎片。</li><li>缺：有内部碎片，分区固定灵活度不高，利用率低，无法多进程共享一个内存区。</li></ul><p><strong>动态分区分配</strong> (多道程序) / <strong>可变式分区分配</strong></p><ul><li><p>内存划分：系统区 + 用户区。不预先划分，进程要多大，划分多大。</p></li><li><p>一表一链：‘空闲分区表’ + ‘空闲分区链’ ：分区号、容量、起始地址、状态。将空闲的区域通过链表形式串联起来。</p></li><li><p>采用动态分区分配算法 (4)：(下文) 首次、最佳、最差、邻近</p></li><li><p>内存回收：内收内村后，会更新链、表信息。合并问题连续的内存空间。</p><ul><li><p>优：无内部碎片，灵活度，利用率高</p></li><li><p>缺：有外部碎片，可以用紧凑技术解决。动态算法有开销。当有大作业来到时，其存储空间的申请可能会得不到满足。</p></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题动态分区分配算法">问题：动态分区分配算法<a class="hash-link" href="#问题动态分区分配算法" title="标题的直接链接">​</a></h3><p><strong>首次适应算法</strong>：（First Fit，FF）—— <strong>最佳</strong></p><p>把空间分区按照地址递增的次序用链表串联。进程分配内存时顺序查链表，找到第一个符合的，空间足够大的分区进行分配。把该分区划分出和进程所需空间相等的内存，剩余内存用链表继续串联。</p><ul><li><p>优：综合性能最佳，算法开销小，不需要重排列分区。</p></li><li><p>缺：在低地址区，小碎片 (外部碎片) 会越来越多，从低地址查表，浪费开销。</p></li></ul><p><strong>邻近适应算法</strong>：（Next Fit，NF）</p><p>在首次适应算法的基础上，把队列改成循环队列。这样不用每次从队首开始查找，而是从上次查找分区位置开始查找。</p><ul><li><p>优：不需要每次从低地址小分区开始查找，提升速度、算法开销小。</p></li><li><p>缺：高地址的大分区可能储备不足，大进程得不到满足。</p></li></ul><p><strong>最佳适应算法</strong>：（Best Fit，BF）</p><p>链表按照容量递增顺序组织。从小到大查表，优先用最小的。</p><ul><li><p>优：保留许多大分区满足大进程需求</p></li><li><p>缺：产生许多难以利用的小碎片 (外部碎片)，算法开销大，需要频繁重排列链表。</p></li></ul><p><strong>最差适应算法</strong>：（Worst Fit，WF）</p><p>链表容量递减顺序。从大到小查表，优先用最大的。</p><ul><li><p>优：减少小碎片的产生</p></li><li><p>缺：大分区不足，大进程得不到满足，算法开销大，频繁重排列链表。</p></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题解决内存中的碎片问题">问题：解决内存中的碎片问题<a class="hash-link" href="#问题解决内存中的碎片问题" title="标题的直接链接">​</a></h3><p><strong>拼接 / 紧凑 / 紧缩技术</strong>：已分配分区移动到内存一端，让碎片可以合并。</p><p>拼接时机：</p><ol><li>出现分区回收时，就拼接（过于频繁）。</li><li>有作业找不到合适空间 + 内存碎片容量足够时，拼接。 <ul><li>缺点：系统开销大</li></ul></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题-基本分页存储管理">问题：🌟 基本分页存储管理<a class="hash-link" href="#问题-基本分页存储管理" title="标题的直接链接">​</a></h3><p>如果内存连续分配，一定会产生外部碎片问题，尽管拼接技术可以解决，但算法复杂，大规模移动内存代价过高。</p><p>基本思想：<strong>进程分页</strong>、<strong>内存分块</strong>。各页面可离散的放置到各内存块中。</p><ul><li>页、页面：进程被划分成若干大小相等的区域。<ul><li>查找方式：页号 + 页内偏移。也就是页面的起始地址 + 长度。</li></ul></li><li>块、物理块：内存被划分成与页面大小相等的区域。</li><li>页框：与页面大小相等的物理块。</li><li>页表：存放在内存中。数组：页号 (隐含) + 块号。将页面和物理快一一对应。</li></ul><p> <strong>逻辑地址</strong> 到 <strong>物理地址</strong> 的转换：</p><p>通过分页查找物理地址 (数据)，需要 <strong>两次内存访问</strong>：</p><ol><li>访问页表。内存中查找页表：页号 + 页内偏移，找到对于物理块号，计算物理地址。</li><li>访问数据。通过物理地址，访问内存，取出数据。</li></ol><p><strong>💊 改进：具有快表的地址变换机构</strong></p><blockquote><p>计算机硬件中，处理速度越快的设备，价格也昂贵。</p><ul><li>存储设备中，越接近 CPU 的设备速度越快，但其内存空间也越少，所以要更珍惜使用。外存、内存、高速三级缓存、高速二级缓存、高速一级缓存。</li></ul><p>通常改进的思路，就是提取 <strong>热点项目</strong>，然后存放在更快一级的内存设备中。</p><ul><li><strong>达到以「价格 + 空间」换「速度」的效果。</strong></li></ul></blockquote><p>若页表全部放在内存中，则存取一个数据或一条指令只要少访问两次内存，速度有点慢，引入快表。</p><ul><li><strong>局部性原理</strong>：<strong>热内存</strong>。即在⼀段时间内，整个程序的执⾏仅限于部分代码区。执⾏所访问的存储空间也局限于某个内存区域。<ul><li>时间局部性：部分代码的执行，集中在较短的时期内。<ul><li>while 循环，一段时间反复使用。</li></ul></li><li>空间局部性：部分代码的执行，集中在相邻的物理地址。<ul><li>数组挨个赋值，相邻的单位会经常访问。</li></ul></li></ul></li></ul><p><strong>快表 TLB</strong>：存储在 CPU 的高速缓存中，速度快，存放经常使用的页表项。</p><p> 改进后，<strong>逻辑地址</strong> 到 <strong>物理地址</strong> 的转换：</p><ol><li>查快表：若直接若命中，则可直接计算物理地址 3，否则查慢表；</li><li>进入内存查页表：找到物理块，然后更新快表；<ul><li>快表更新：长时间不查找的表项删除；刚查找的表项添加。</li></ul></li><li>计算物理地址。</li><li>进入内存，访问物理地址。</li></ol><p><strong>💊 改进：二级页表 / 多级页表</strong></p><p>改进原因：</p><ol><li>页表必须连续存放，单页表容易占用过大连续空间；</li><li>有些地址长时间不会访问，所以整个页表无需全部常驻内存。</li></ol><p>改进效果：</p><ol><li>带个页表的长度大大减小，所以访问速度得到提升。</li><li>但多个页表，占用空间提升。</li><li>二级页表，还有三次内存访问。</li></ol><p> 改进后，<strong>逻辑地址</strong> 到 <strong>物理地址</strong> 的转换：</p><ol><li>访问内存，查外层页表：找到内层页表地址</li><li>访问内存，查内层页表：找到物理块号</li><li>计算物理地址</li><li>访问内存，访问目标物理地址。</li></ol><p><strong>💊 优缺点：</strong></p><p>优点：内存利用率高、实现了离散分配、便于存储访问控制、无外部碎片。</p><p>缺点：需要硬件支持（尤其是快表）、内存访问下降（二级页表）、有内部碎片。进程是无逻辑的等量分页，所以不方便程序内数据共享。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题-基本分段存储管理">问题：🌟 基本分段存储管理<a class="hash-link" href="#问题-基本分段存储管理" title="标题的直接链接">​</a></h3><p>分页管理，着重对内存空间进行切分。而分段管理是对进程 / 作业进行切分。一个作业通常是多个程序段 / 数据段组成的，程序员会按照逻辑对作业分段，每段有可识别的名称，根据名称访问相应的程序段或数据段。这样可以实现对相同逻辑的复用。</p><p>基本思想：内存分段。把内存按照程序自身的逻辑关系划分为若干段 (大小不一)。每段从 0 开始编址，一个段必须占据连续空间，但各段可以不相临。</p><p><strong>段表</strong>：段号(隐含) + 段长 + 基址 (该段内存中的始址)。</p><ul><li>段号：代表某个程序段；</li><li>段长：反应作业空间，该程序段占用内存的空间大小；</li><li>基址：反应内存空间，该程序段在内存中的起始位置。</li></ul><p><strong>逻辑地址</strong> 到 <strong>物理地址</strong> 的转换：</p><ol><li>系统为每一个进程建立一个段表，</li><li>进入内存，查段表，找到对应段表项</li><li>计算物理地址</li><li>进入内存，访问目标物理地址。</li></ol><p><strong>💊 优缺点：</strong></p><p>优点：便于程序模块化处理、便于动态链接和共享、无内部碎片。</p><p>缺点：需要硬件支持、有外部碎片、为满足分段的动态增长和减少外部碎片，要拼接(紧凑)技术。</p><p><strong>💊 分段与分页相比：</strong></p><ul><li><p>分页：页，物理单位，有内部碎片，用户透明，进程地址空间一维：页地址。</p></li><li><p>分段：段，逻辑单位，有外部碎片，用户可见，进程地址空间二维：段名+段内地址</p></li><li><p>分段优点：段按照逻辑划分，方便信息的共享和保护（段内代码和数据可共享），段长过大的话，不容易找到内存和可放下的连续空间。</p></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题-基本段页式存储管理">问题：🌟 基本段页式存储管理<a class="hash-link" href="#问题-基本段页式存储管理" title="标题的直接链接">​</a></h3><p>思想：分段 + 分页</p><ul><li>分段的优点：易于信息共享与保护</li><li>分页的优点：内存利用率高，无外部碎片；解决段长过大不易找连续空间。</li></ul><p><strong>一个进程：1 个段表 + n 个页表</strong></p><ol><li>分段：将程序的空间地址，按照程序逻辑划分若干段；</li><li>分页：各段中，划分若干相等大小的页；</li><li>内存：划分为与页相等的物理块，以物理块为进程分配内存。</li></ol><p>创建的实体 ：</p><ul><li>段表：段号(隐含) + 页表长度 + 页表始址</li><li>页表：页号(隐含) + 内存块号</li></ul><p>​	</p><p><strong>逻辑地址</strong> 到 <strong>物理地址</strong> 的转换：</p><ol><li>访问内存，查段表：找到页表起始地址。</li><li>访问内存，查页表：找到物理块号。</li><li>计算物理地址</li><li>访问内存，访问目标物理地址。</li></ol><p>⚠️ 3 次访问内存：段表、页表、访问物理地址</p><ul><li>如果在页表中引入快表，可以一次命中，只 2 次访问。</li></ul><p><strong>💊 优缺点：</strong></p><p>优点：上面有</p><p>缺点：内部碎片并没有做到和页式一样少。一个程序往往有很多段，平均下来段页式的内部碎片比页式还多。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题内存的扩充">问题：内存的扩充<a class="hash-link" href="#问题内存的扩充" title="标题的直接链接">​</a></h3><p><strong>覆盖技术</strong> (早期操作系统)</p><ol><li>一个大程序划分为若干‘覆盖’ = 程序段</li><li>内存中：一个固定区 (主程序)。不会掉入调出。存放最活跃的程序段。</li><li>内存中：若干覆盖区。互斥的 ‘覆盖’，可共享一个覆盖区，运行时动态掉入调出。</li></ol><ul><li>缺点：程序员需要声明覆盖结构，不透明，增加编程负担。</li></ul><p><strong>交换技术</strong> (内存调度)</p><ul><li>当缺页率频发、内存不足时，执行交换技术。</li></ul><ol><li>内存中：调出某些进程放到外存，保留PCB，移至挂起态。</li><li>外存中：设置文件区、对换区 (交换区)。对换区读取速度快，且有就绪挂起、阻塞挂起队列。</li></ol><p><strong>虚拟技术</strong>（后面的问题：虚拟内存）</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题虚拟内存技术">问题：虚拟内存技术<a class="hash-link" href="#问题虚拟内存技术" title="标题的直接链接">​</a></h3><p>引入原因，之前介绍的存储方式，有两个特点：</p><ol><li>一次性：作业 / 程序全部装入内存后，才开始执行。</li><li>驻留性：作业 / 程序常驻内存，直到运行完全结束。</li></ol><p>根据 <strong>局部性原理</strong>，程序在执行过程中，有写代码的使用较少（如错误处理），而有些代码需要较长时间的 I/O 处理，这些代码占用了很多内存，导致内存空间浪费。</p><p>虚拟内存：一种能够让作业 / 程序 部分装入，就可以运行的存储管理技术。</p><ol><li><strong>部分装入</strong>。在程序装入内存时，可以将程序的一部分放入内存，而其余部分放在外村，然后启动程序。程序在内存中 <strong>离散存储</strong>。</li><li><strong>请求掉入</strong>。在程序执行过程中，当访问的信息不在内存时，再由操作系统将所需的部分调入内存。</li><li><strong>置换功能</strong>。操作系统可以将内存中暂时不用的程序段，置换到外存中，腾出空间。</li><li><strong>虚拟内存</strong>。从效果上看，计算机系统提供了一个比实际内存大的多的存储容量。</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题请求分页存储管理">问题：请求分页存储管理<a class="hash-link" href="#问题请求分页存储管理" title="标题的直接链接">​</a></h3><p>分页存储管理解决了内存中的外部碎片问题，但它要求程序需要一次性全部调入内存，导致不常用的代码块占据内存中。同时如果作业太大，也有可能无法完整放入内存中。</p><p>思路：进程分页 + 请求调页功能 + 页面置换功能</p><ul><li>先将程序部分载入内存执行，当需要其他部分时，再调入内存。</li><li>部分装入、请求调入、值换功能、虚拟内存。</li></ul><p>页表结构</p><table><thead><tr><th>页号(隐)</th><th align="left">物理块号</th><th align="left">状态位</th><th align="left">访问字段</th><th align="left">修改位</th><th align="left">外存地址</th></tr></thead></table><ul><li><p>页号、物理块号：分页存储中原有的表项，反映进程页在内存中的位置。</p></li><li><p>状态位：判断是否在内存中，如果不在则发生 <strong>缺页中断</strong>。</p></li><li><p>访问字段：记录页面在一段时间内的访问次数，供值换算法参考。</p></li><li><p>修改位：页面调入内存后是否被修改过。当 CPU 以写方式访问页面时，调整修改位。</p><ul><li>内存中的页面在外存上有副本，若页面没被修改，则该页面值换出时，可直接丢弃，减少磁盘写的次数。</li></ul></li></ul><p><strong>逻辑地址</strong> 到 <strong>物理地址</strong> 的转换：</p><ol><li><p>提取：逻辑地址 = 页号 + 页内偏移量；</p></li><li><p>判断：页号 &lt; 页表长度 (页表寄存器)，越界中断；</p></li><li><p><strong>查快表</strong>：直接命中，则跳至 6；</p></li><li><p><strong>查慢表</strong>：若不在慢表中，则执行：缺页中断 + 请求调页；</p></li><li><p><strong>更新快表</strong>：更新快表信息；</p></li><li><p><strong>修改页表</strong>：访问位 + 修改位（若数据修改）；</p></li><li><p>计算地址：物理地址 = 内存块号 * 块大小 + 页内偏移量；</p></li></ol><ol start="8"><li>访存：访问内存中的目标物理地址。</li></ol><p><strong>缺页中断</strong>：</p><ol><li><p><strong>查找缺页</strong>：保留现场，外存中寻找缺页。</p></li><li><p><strong>判断空间</strong>：如果内存已满，则执行：页面置换。</p></li><li><p><strong>缺页调入</strong></p></li><li><p><strong>更新页表</strong></p></li></ol><p>⚠️ 缺页中断属于内中断：故障。</p><p><strong>页面置换</strong>：</p><ol><li><strong>执行算法</strong>：执行对应的置换算法。</li><li><strong>判断修改</strong>：判断该页有无修改，如果有，则把页面写入外存中，没有则直接丢弃。</li></ol><p><strong>💊 优缺点：</strong></p><p>优点：离散存储，减少连续存储导致的外部碎片；虚拟存储，提高内存的利用率；</p><p>缺点：必须硬件支持 (缺页中断)；会发生抖动现象 (页面频繁调入调出)。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题页面置换算法-5">问题：页面置换算法 5<a class="hash-link" href="#问题页面置换算法-5" title="标题的直接链接">​</a></h3><p>也称页面淘汰算法。</p><ul><li>缺页率 = 缺页中断次数 / 总访问次数</li></ul><p><strong>最佳置换</strong>（OPT : Optimal）</p><p>淘汰未来最长时间不妨问的、以后不会再用的页面 (预知未来)。</p><ul><li><p>优：缺页率最小、性能最好。</p></li><li><p>缺：理想型算法，无法实现。</p></li></ul><p><strong>先进先出</strong>（FIFO）</p><p>淘汰最先进入内存的页面，维护一个有先后次序的队列。</p><ul><li><p>优：实现简单</p></li><li><p>缺：性能最差，Belady 异常：可调动的物理块数越多，可能缺页中断次数也变多。</p><ul><li>最早调入的页面，可能是使用最频繁的页面。</li></ul></li></ul><p><strong>最近 / 最久未使用置换</strong>（LRU：Least Recently Used）</p><p>淘汰过去最久没访问的页面。维护页面的访问字段：上次访问时间t，淘汰t最大的页面。</p><ul><li><p>优：性能尚可</p></li><li><p>缺：需要硬件支持，算法开销大，每次淘汰时，需要遍历统计访问次数的数据结构。</p></li></ul><p><strong>时钟置换</strong>（CLOCK）/ <strong>最近未用</strong>（NRU：Not Recently Used）</p><p>（1）<strong>简单时钟置换</strong>（NRU）</p><p>给每个页面设置访问位：1 有访问，0无访问。表示该页最近是否有被访问。</p><p>维护一个指向内存中所有页面的循环链表。当程序访问链表中的页面时，就设置访问位为 1，当在链表中找不到时，就需要挑选一个为 0 的淘汰掉，然后插入需要访问的页面。</p><ul><li><p>淘汰时：</p><ul><li><p>第一轮：循环检查访问位，遇 0 则选择换出；遇 1 则置为 0 后，继续检查。</p></li><li><p>第二轮：如果原先全为 1，需要第二轮查找，此时已经全部置为 0，一定能找到可替换的页面。</p></li></ul></li><li><p>优：实现简单，开销小，不需要很多硬件支持；</p></li><li><p>缺：未考虑如果页面被修改，需要输出到外存中，有外存写入开销。</p></li></ul><p>（2）<strong>改进型时钟置换</strong>（改进型NRU）</p><p>优化：优先淘汰被修改过的页面。</p><ul><li><p>统计：访问位 + 修改位。（1 , 1）表示（被访问过+ 被修改过）</p></li><li><p>淘汰时：</p><ul><li>第一轮：淘汰（0 , 0），不修改数值，只为找到（0，0）的可替换位。</li><li>第二轮：淘汰（0 , 1），扫描过的页面，<strong>访问位</strong> 都置为 0。</li><li>第三轮：淘汰（0 , 0），不修改数值，只为找到（0，0）的可替换位，此时访问为都为 0，一定能找到可替换的页面。</li></ul></li><li><p>优：考虑全面，算法开销适中，综合性能尚可。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="第四章文件管理">第四章：文件管理<a class="hash-link" href="#第四章文件管理" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题文件基本知识">问题：文件基本知识<a class="hash-link" href="#问题文件基本知识" title="标题的直接链接">​</a></h3><p>文件系统负责管理文件，为用户提供对文件进行存取、共享、保护的方法。</p><ul><li>逻辑结构：用户角度观察到的文件组织形式。——逻辑地址</li><li>目录结构：文件之间的组织与管理。</li><li>物理结构：计算机实际的组织形式，在外存中的存放方式。 —— 物理地址</li><li>存储空间管理：外存中空间块的管理。</li><li>文件共享 / 保护：操作系统提供的其他支持。</li><li>系统调用：操作系统向上提供的基本功能。</li><li>基本操作 6：创建、删除、打开、关闭、读文件、写文件。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题文件的打开过程">问题：文件的打开过程<a class="hash-link" href="#问题文件的打开过程" title="标题的直接链接">​</a></h3><ol><li>系统将文件的属性从外存复制到内存，并设定一个编号（索引），返回给用户。</li><li>当用户要对该文件进行操作时，不需要查询目录，只需利用索引向系统提出请求。</li></ol><p>避免了系统对文件的再次检索，节约了检索开销，提高了对文件的操作速度。</p><ul><li>用户：看到文件的 <strong>逻辑结构</strong>。操作系统：通过 <strong>目录</strong> 找到文件的 <strong>FCB</strong> 信息，通过 FCB 信息，找到文件的 <strong>物理地址 / 索引地址</strong>，最终找到 <strong>物理地址</strong>，通过 <strong>物理结构</strong> 访问到具体的 <strong>物理地址</strong>，得到结果。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题文件的逻辑结构">问题：文件的逻辑结构<a class="hash-link" href="#问题文件的逻辑结构" title="标题的直接链接">​</a></h3><p>文件的物理结构：从计算机角度出发，文件在外村上的存放和组织形式。</p><p>文件的逻辑结构：用户观察到的文件组织形式，是用户可以直接处理的数据和结构。</p><p>文件的逻辑结构划分为：</p><ol><li>无结构文件：流式文件</li><li>有结构文件：记录式文件（类似表格）：关键字（key）+ 数据项。<ul><li>可变长记录：数据项长度不确定。</li><li>定长记录：数据项长度严格一样。</li></ul></li></ol><p><strong>💊 顺序文件</strong></p><p>连续结构。最简单的文件结构。将一个逻辑文件的信息连续存放。</p><ol><li>存放位置：</li></ol><ul><li>逻辑上：顺序排列</li><li>物理上：相邻 (顺序存储) 、不相邻 (链式存储)<ul><li>链式存储 无法实现随机存取，只能从头查找。</li></ul></li></ul><ol start="2"><li>排序方式：<ul><li>串结构：按存放时间记录，与关键字顺序无关。</li><li>顺序结构：按关键字顺序排放。支持关键字快速查找。</li></ul></li><li>记录的长度：<ul><li>变长记录顺序文件：无法随机存取，查询时只能从头依次查找。</li><li>定长记录顺序文件：可随机存取，支持查询随机访问。</li></ul></li></ol><p><strong>顺序结构</strong> + <strong>定长记录</strong> 的顺序文件：可以实现关键字快速查找、随机访问。</p><p>通常来讲，默认顺序文件是：物理上 <strong>顺序存储</strong> + <strong>串结构</strong> 的文件。</p><ul><li>缺点：不方便 增 / 删 文件。连续存放碎片较多，可变长不易快速检索。</li><li>优点：实现简单，可以支持随机存储。</li></ul><p><strong>💊 索引文件</strong></p><p>索引结构为一个逻辑文件的信息建立的一个索引表。</p><ol><li>索引表：一个定长记录的顺序文件，可快速查找索引项。<ul><li>索引号(隐含) + 长度 + 指针地址</li><li>索引表不唯一，可根据数据项的不同建立多个类型的索引表（数据库）</li></ul></li><li>逻辑文件：在物理上可以离散存放，通过索引项查找。</li></ol><ul><li>优点：解决了可变长记录文件的随机访问；方便 增 / 删 文件。</li><li>缺点：引入索引表，增加存储空间开销；查表需要设计算法。</li></ul><p><strong>💊 索引顺序文件</strong></p><p>类似一本书。有目录（索引表），章节（分组）。</p><ol><li>逻辑文件：按顺序把文件进行分组，得到关键字（章节）。</li><li>索引表：按照关键字排序，建立索引表。<ul><li>索引项：是每个分组的第一项记录 （每章节的开头）。</li></ul></li><li>查找方式：<ol><li>顺序查找索引表。</li><li>找到分组。</li><li>顺序查找分组。 </li></ol></li></ol><p>优点：缩短索引表长，提升存取速度；记录过多，可以建立多级索引。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题文件的目录结构">问题：文件的目录结构<a class="hash-link" href="#问题文件的目录结构" title="标题的直接链接">​</a></h3><p>实现方式</p><ul><li>FCB 文件控制块：每个文件都对应一个 FCB，记录文件相关属性。</li><li>文件目录：由 n 个 FCB 项组合而成。目录项就是 FCB。</li><li>操作方式：搜索、创建、删除、显示、修改文件。</li></ul><p><strong>索引节点</strong>：对 FCB 进行改进。</p><ul><li>改进原因：找文件需要查看文件名，而 FCB 的目录项过大，全部从外存中调入开销增大。若目录项过大，占用多个磁盘块，在查找时，一次只能读一个磁盘块，需要多次 I/O。</li><li>目录项：不再保存完整的 FCB，而只保存 <!-- -->[文件名, 索引结点指针]<!-- -->。每个文件建立一个索引结点，通过指针找到结点。这样就缩小了目录的体积。</li></ul><p><strong>💊 目录的结构 4：</strong></p><p><strong>单级目录结构</strong> （原始）</p><p>整个系统只有一张目录表，每个文件为一个表项。</p><ul><li>缺：查找速度慢，文件不允许重名。</li></ul><p><strong>两级目录结构</strong> （用户分类）</p><p>系统为每个用户建立一个单独的用户文件目录 UFD User File Directory。</p><ul><li>文件目录结构：1 个主文件目录 MFD + n 个用户文件目录 UFD。</li></ul><p>主文件目录：记录系统中各个用户文件目录。</p><p>用户文件目录：记录该用户建立的所有文件和说明信息。</p><ul><li><p>优：查找速度提高，不同用户文件可以重名，增加用户间权限。</p></li><li><p>缺：不方便于用户间的文件共享，无法对文件分类。</p></li></ul><p><strong>多级目录结构</strong> / <strong>树形结构</strong> （路径寻找）</p><p>将二级目录结构推广，变成多级目录结构。通过路径名来唯一标识文件。从根路径出发为绝对路径，从当前目录出发为相对路径。</p><ul><li><p>结构：1 个根目录 + n 个子目录。 每个文件有唯一标识符，对用户透明。</p></li><li><p>优：可对文件分类、可重名、结构清晰。</p></li><li><p>缺：不方便文件共享、目录较多会频繁 I/O 操作，影响查找速度。</p></li></ul><p><strong>无环图目录结构</strong>（用户共享）</p><p>在树形结构的基础上，增加指针。可以让不同文件名，指向同一文件。</p><ul><li><p>这种方法在删除文件时增加麻烦。类似 js 的对象销毁机制。需要对引用计数，记录用户链接到该文件的总数。当引用数量为 0 时，才可以销毁。</p></li><li><p>优：可以共享文件。</p></li><li><p>缺：结构更复杂，不方便管理。</p></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题硬链接--软链接">问题：硬链接 / 软链接<a class="hash-link" href="#问题硬链接--软链接" title="标题的直接链接">​</a></h3><p>文件共享是一个重要功能。是指不同的用户可以使用同一个文件。实现方式有 硬 / 软链接 两种方式。</p><p><strong>基于索引结点的共享方式（硬链接）</strong></p><p>类似 js 中不同的指针指向相同的 object 对象。</p><p>索引结点，是把 FCB 中的文件描述信息单独构成一个数据结构，也就是说，物理块的信息在索引结点中保存。所以目录中可以只保存 文件名 + 索引指针，大大减少了目录体积。</p><p>所以，硬链接的思想是让两个不同的目录项，指向相同的索引结点。也就是不同的目录名，保存的结点指针，指向了相同的的文件地址。这样就实现了共享。</p><ul><li>优点：通过索引指针，可以直接访问到对应的文件，速度快。</li><li>缺点：文件拥有者无法删除被共享的文件，因为其他用户保持了该文件的索引指针</li></ul><p><img loading="lazy" alt="截屏2022-08-14 02.12.19" src="/assets/images/截屏2022-08-14 02.12.19-8e51d3c1213309aa6b4472eae6be51ee.png" width="1512" height="796" class="img_E7b_"></p><p><strong>基于符号链实现文件共享（软链接）</strong></p><p>类似 window 中的快捷方式。</p><p>目录可以新增一个 <strong>链接</strong> 类型的目录项。该目录项保存：文件名 + 文件路径。并不是保存索引指针，而是通过 <strong>文件路径</strong>，可以访问到其他文件，以实现共享效果。</p><ul><li>如果 B 用户想访问 A 用户的某个文件。B 可以在自己的目录中创建一个新的目录项，该目录像并不是一个 <strong>文件</strong> 类型的目录，而是 <strong>链接</strong> 类型，同时保存了文件的路径。可以通过路径访问到 A 的那个文件。</li></ul><ul><li>优点：文件拥有者可以随意删除自己的文件。删除后，其他 <strong>链接</strong> 并不会被删除，只是不能正确访问文件。</li><li>缺点：通过 <strong>链接</strong> 访问文件，需要通过路径依次查找目录，开销很大。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题文件的物理结构">问题：文件的物理结构<a class="hash-link" href="#问题文件的物理结构" title="标题的直接链接">​</a></h3><p>非空闲磁盘块的分配、外存的分配方式：</p><ul><li>静态分配：文件建立时，一次性分配所需的全部空间；</li><li>动态分配：根据动态增长的文件长度进行分配，可以一次分配一个物理块。</li></ul><p><strong>顺序分配 / 连续分配</strong></p><p>分配是连续的磁盘块。用户必须提前说明文件大小，系统查找空闲区的管理表格，如果有连续的空间可以容纳，就分配空间；如果空间不足，用户进程必须等待。</p><ul><li>目录项内容：起始块号，文件长度</li><li>优点：顺序存取速度快，支持随机访问。</li><li>缺点：产生碎片，空间不足需要紧缩技术。文件拓展不便。</li></ul><p><strong>链接分配 （离散分配）</strong></p><p>用户事先不知道文件的体积，从用离散分配方式，分为：隐式链接、显式链接。</p><p><strong>（1）隐式链接</strong></p><p>每个磁盘块中，有一个指针指向下一个磁盘块，串联起来形成链表。</p><ul><li>目录项内容：文件名，…，起始块号，结束块号</li><li>优点：解决外部碎片问题，外存利用率高，易于实现文件拓展。</li><li>缺点：由于是链表链接，只能从头顺序访问，不能随机读取，记录指针占用内存。</li></ul><p><strong>（2）显式链接</strong></p><p>建立文件分配表，通过表可以直接查找所有的链接，而不需要在磁盘中顺次查找。一个磁盘对应一个FAT，且该表 <strong>常驻内存</strong> 中。</p><ul><li>文件分配表 (FAT) 内容：物理块号 + 下一块号。</li><li>优点：隐式链接优点 + FAT 实现随机访问、不需要磁盘读取，加快速度。</li><li>缺点：FAT 占用一定的外存、内存空间。</li></ul><p><strong>索引分配</strong></p><p>一个文件分配一个索引块，索引块中存放索引表，索引表中的每个表项对应具体的物理块。<strong>索引块在外存 / 磁盘中</strong>。</p><ul><li>索引表表项内容：物理块（相当于页表）</li><li>目录项内容：文件名，…，索引块</li><li>优点：支持随机、顺序访问，文件易扩展，只需增加索引表表项即可。</li><li>缺点：索引表占用磁盘空间。访问数据块需要先读入索引块 (可常驻内存)，增加额外的 I/O 操作。</li></ul><p><strong>改进</strong>：若索引表过长，可能需要占用多个索引块。</p><ul><li><strong>以空间换时间</strong></li></ul><ol><li><p><strong>链接方案</strong></p><ul><li>方法：把每个索引表用指针链接起来。</li><li>问题：索引需顺序查表，多次 I/O 频繁。</li></ul></li><li><p><strong>多层索引</strong> （相当于多层页表）</p><ul><li>方法：顶层索引块指向第二层索引块，以此类推。FCB 中只存放顶层索引块</li><li>问题：各表需要小于一个索引块 / 磁盘块 / 数据块。</li></ul></li><li><p><strong>混合索引</strong> （根据需求调整索引层级）</p><ul><li>目录项内容：可以是 索引块 / 数据块起始块号；</li><li>直接地址索引：直接指向数据块（两次I/O：索引块 + 访问数据）</li><li>一级间接索引：指向单层索引表（三次I/O：两次索引 + 访问数据）</li><li>两级间接索引：指向两层索引表（四次I/O：三次索引 + 访问数据）</li></ul></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题文件的存储空间管理">问题：文件的存储空间管理<a class="hash-link" href="#问题文件的存储空间管理" title="标题的直接链接">​</a></h3><p>系统记录了空闲存储空间的情况，以便对存储空间进行分配。</p><p>磁盘划分为：目录区 + 文件区</p><ul><li>目录区：存放 FCB、相关管理信息（空闲表、位示图、超级快等）</li></ul><p>文件空闲存储空间管理 4 种办法：P217</p><p><strong>空闲表法</strong> （连续） </p><p>所有空闲文件单独建立一个目录。</p><ul><li>空闲表：记录每个连续空闲区：（起始盘号，盘块数）</li><li>分配：首次适应、最佳适应、最差适应、邻近适应</li><li>连续分配 —— 动态分区分配</li><li>回收：分区合并 + 新增表项按算法排序</li><li>特点：实现简单，必须采用连续，有碎片。</li></ul><p><strong>空闲链表法</strong> （离散 / 连续）</p><ul><li>空闲盘块链：把每一个空闲磁盘块链接起来。</li><li>空闲盘区链：连续的空闲盘块组成一个空闲盘区。把空闲盘区链接起来，标明区内，块的数量</li><li>空闲盘块：离散方式；空闲盘区：离散 + 连续方式</li><li>回收 / 分配：与上相同。</li><li>特点：可离散，提高利用率；需要算法提高分配速度（链表需要从头顺次查找）</li></ul><p><strong>位示图法</strong></p><p>把磁盘切分为 n 个物理块。统计物理块是否空闲。</p><ul><li>位示图：0空闲盘；1已分配。一个磁盘块对应一个数字。</li><li>分配：四个适应算法；回收：把1置为0。</li><li>特点：位示图较小，可常驻内存中，提高分配速度；需要图中坐标与盘块号转换，增加开销</li></ul><p><strong>成组链接法</strong>（UNIX系统）</p><p>适用于大型文件系统。将一个文件的所有空闲快按每组 100 块分成 n 组。每组的第一个盘块中，记录了下一组所有盘块的地址。第一个组的盘块，被单独的超级块记录。</p><ol><li>设置超级块 + 若干组（每组100个空闲磁盘）</li><li>每组第一个空闲块，记录下一组的相关信息（数量，块号）</li><li>第一组的信息，在超级块中记录。<strong>超级块常驻内存</strong>。</li></ol><ul><li>分配：检查超级块，充足则分配，不充足则分配第一组，同时修改链接信息。</li><li>回收：检查超级块，不超过100块则添加进超级块；超过则新建分组。</li></ul><p><img loading="lazy" alt="截屏2022-08-14 13.59.51" src="/assets/images/截屏2022-08-14 13.59.51-10537c53558bfb872b765ae55ef223fd.png" width="1230" height="692" class="img_E7b_"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题文件的保护">问题：文件的保护<a class="hash-link" href="#问题文件的保护" title="标题的直接链接">​</a></h3><p><strong>口令保护</strong></p><p>每个文件设置一个 “口令”，保存在 FCB 中，用户必须对口令访问。</p><ul><li>优：开销小（口令占用少量空间）；验证时间段（ PCB 中口令对上即可）</li><li>缺：口令在系统内不安全，攻破后随意访问。</li></ul><p><strong>加密保护</strong></p><p>使用 “密钥” 对文件加密，对称密钥，非对称密钥。</p><ul><li>优：安全性强，改变了数据内容，密码不放在系统中。</li><li>缺：加密 / 解密开销大。</li></ul><p><strong>访问控制</strong></p><p>在 FCB 中，建立访问控制表（ACL），记录各用户对文件的访问权限。</p><ul><li>优：灵活，权限相同，则用户可按组记录。</li><li>缺：表有开销，一个目录有权限信息，其内容也要加权限信息</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题文件系统层次结构">问题：文件系统层次结构<a class="hash-link" href="#问题文件系统层次结构" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="截屏2022-08-14 02.52.47" src="/assets/images/截屏2022-08-14 02.52.47-d4b2b87514ad466c8d59778f3f8412f1.png" width="1372" height="850" class="img_E7b_"></p><p>用户 =&gt; 用户接口 =&gt; 文件目录系统 =&gt; 存取控制模块 =&gt; 逻辑文件系统与文件信息缓冲区  =&gt; 物理文件系统</p><ul><li>物理文件系统：辅助分配模块 + 设备管理模块 ( =&gt; 设备）</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题磁盘调度算法">问题：磁盘调度算法<a class="hash-link" href="#问题磁盘调度算法" title="标题的直接链接">​</a></h3><p>磁盘、磁道、扇区</p><ul><li><p>磁道：磁盘划分的一圈一圈的范围。通过磁头移动，改变柱面，更换磁道。</p></li><li><p>扇区：= 磁盘块。每一圈又划分为小段小段。</p></li><li><p>磁盘的物理地址 = 柱面号，盘面号，扇区号。</p></li></ul><p><strong>磁盘调度算法 2 + 4</strong></p><p>磁盘是可以被多个进程共享的设备。当有多个进程都请求访问磁盘时，采用适当的算法，保证各个进程对磁盘的平均访问时间（<strong>主要是寻道时间</strong>）最短。</p><p><strong>1. 先来先服务</strong>（FCFS）</p><p>按照先后顺序依次寻找、访问。</p><ul><li>优：公平，如果访问的磁道集中，则性能尚可。</li><li>缺：若进程竞争使用，磁道分散，寻道时间很长，性能极差。</li></ul><p><strong>2. 最短寻找时间优先</strong>（SSTF）</p><p>优先处理与当前磁头最近的磁道。</p><ul><li>优：平均寻道时间短。</li><li>缺：确保短期寻道时间最短，不一定总体寻道时间最短。有些进程会饥饿。</li></ul><p><strong>3. 扫描算法</strong>（SCAN）</p><p>改进：解决最短寻找时间优先的饥饿问题，让磁头在触碰磁道边缘才能往返移动。</p><ul><li>磁头必须移动到最外侧磁道，才能往回移动。移动期间访问队列中的磁道。</li><li>优：性能较好，解决饥饿问题，</li><li>缺：<ul><li>达到边缘才能返回。 改进：LOOK 算法</li><li>边缘的磁道响应间隔不平均。 改进：C-SCAN 算法</li></ul></li></ul><p><strong>4. LOOK 调度算法</strong> —— 电梯算法</p><p>改进：如果磁道在当前方向上没有访问请求，则可以提前掉头。</p><ul><li>优：寻道时间比扫描算法进一步缩短。</li></ul><p><strong>5. 循环扫描算法</strong>（C-SCAN）</p><p>改进：磁头必须沿一个方向扫描。扫描到最边缘时，掉头直接回到初始端，重新扫描。</p><ul><li>优：对各个位置的磁道响应频率很平均。</li><li>缺：只有达到最边上才掉头，浪费了时间。 改进：C-LOOK 算法。</li></ul><p><strong>6. C-LOOK 调度算法</strong></p><p>改进：方向上没有访问请求，则立刻掉头。同时，掉头不是回到初始端，而是请求位置。</p><ul><li>优：结合了 LOOK 和 C-SCAN 算法，寻道时间最短。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题提高磁头读取速度的办法">问题：提高磁头读取速度的办法<a class="hash-link" href="#问题提高磁头读取速度的办法" title="标题的直接链接">​</a></h3><ol><li>交替编号<ul><li>办法：编号相邻的扇区，物理上不相邻。</li><li>原理：读完一个扇区，需要间隔时间后再读。</li></ul></li><li>错位命名<ul><li>办法：同一个柱面下，扇区号错位。不同盘面(垂直看)，扇区号要垂直错位。</li><li>原理：读完某盘面的最后一个扇区后，下一个扇区在另一个盘面上，要错开扇区编号。</li></ul></li><li>磁盘地址结构设计<ul><li>地址：柱面号，盘面号，扇区号</li><li>柱面最后移动，因为移动柱面要移动磁头，费时间。</li></ul></li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="第五章设备管理">第五章：设备管理<a class="hash-link" href="#第五章设备管理" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题设备控制器的功能-4">问题：设备控制器的功能 4<a class="hash-link" href="#问题设备控制器的功能-4" title="标题的直接链接">​</a></h3><ol><li>接受和识别来自 CPU 的命令</li><li>实现 CPU 与设备控制器、设备控制器与设备之间的数据交换</li><li>记录设备的状态供 CPU 查询</li><li>识别所控制的每个设备的地址</li><li>对 CPU 输出的数据或设备向 CPU 输入的数据进行缓冲</li><li>对 I/O 数据进行差错控制</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题io-控制方式-4">问题：I/O 控制方式 4<a class="hash-link" href="#问题io-控制方式-4" title="标题的直接链接">​</a></h3><p>控制方式</p><ul><li>特点：CPU干预频率↘️，一次 I/O 的传输量↗️，数据流向经过的设备↘️。</li><li>改进：每个方式的优点，就是改良上个阶段的缺点；减少 CPU 对 I/O 干预。</li></ul><p><strong>程序直接控制方式</strong></p><p>早期的计算机系统中，没有中断系统。CPU 和 I/O 设备通信时，</p><p>过程：</p><div class="codeBlockContainer_I0IT language-typescript theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-typescript codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token number" style="color:#36acaa">1.</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">CPU</span><span class="token plain"> 对 </span><span class="token constant" style="color:#36acaa">I</span><span class="token operator" style="color:#393A34">/</span><span class="token constant" style="color:#36acaa">O</span><span class="token plain"> 控制器发出命令后，便不断轮询。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">1.</span><span class="token plain"> 等待 </span><span class="token constant" style="color:#36acaa">I</span><span class="token operator" style="color:#393A34">/</span><span class="token constant" style="color:#36acaa">O</span><span class="token plain"> 控制器完成，才进行下一条指令。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">1.</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">CPU</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">发出从</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">内存</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">外设</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">读命令、发出向</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">内存</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">外设</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> 写命令。</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>数据流向：I/O设备 ↔️ CPU ↔️ 内存</p><ul><li>优：实现简单。</li><li>缺：<ol><li>早期 OS 无中断系统，I/O 设备太慢，CPU 盲等，利用率低。</li><li>传输单位是字节，效率低。</li></ol></li></ul><p><strong>中断控制方式</strong></p><p>广泛采用的方式，为了减少 CPU 等待时间，提高 CPU 与 其他设备的并行工作时间</p><p>过程：</p><ol><li>CPU 发出命令后，阻塞需要 I/O 的当前进程，切换至别的进程执行。</li><li>等 I/O 操作完成后，I/O 控制器发出中断信号。CPU 检测到中断，继续执行进程。</li><li>CPU 发出从 (内存/外设) 读命令、发出向 (内存/外设) 写命令。</li></ol><p>要点：CPU 中断检测时机：每个指令周期的末尾。</p><p>数据流向：I/O设备 ↔️ CPU ↔️ 内存</p><ul><li>优：提高利用率。实现了 I/O 设备与 CPU 并行工作。</li><li>缺：<ol><li>执行中断指令需要保护现场，切换进程，频繁中断，增加开销。</li><li>I/O 设备与内存间数据传输，总是需要 CPU 参与，浪费 CPU 利用率。</li><li>传输单位是字节，效率低。</li></ol></li></ul><p><strong>DMA 控制方式 </strong> (直接存储器存取 — DMA 存储器)</p><p>以内存为中心，在外设和内存之间开辟一个直接交换数据的通路。</p><p>过程：</p><ol><li><p>CPU 执行的进程，现在需要 I/O 操作。</p></li><li><p>CPU 发出命令，直接一次性说明所有信息 (数据量、读地址、写地址)，交给 DMA；</p></li><li><p>DMA 控制器在完成一系列指令后，发出中断信号。CPU 检测到中断，切换回来；</p></li><li><p>此时已完成读 / 写命令，直接进入下一个指令周期。</p></li></ol><p>数据流向：I/O设备 ↔️ 内存</p><ul><li><p>优：</p><ol><li><p>传输单位是 “数据块”，连续读写，提高传输速度。</p></li><li><p>数据传输不需要 CPU 干预，DMA 控制器完成。</p></li></ol></li><li><p>缺：</p><ol><li>数据的传送方向、存放输入数据的内存起始地址等都有 CPU 控制。所以 CPU 一条 I/O 指令，只能 读/写 连续的数据块，无法 读/写 离散的。</li><li>每台外设设备，都需要一个 DMA 控制器。当有多台设备时，不经济。</li></ol></li></ul><p><strong>DMA 控制</strong> 与 <strong>中断控制</strong> 的区别：</p><ol><li>中断控制方式，在每个数据传输完成后，中断 CPU；
DMA 控制方式，在所要求的全部数据传输完成后，中断 CPU。</li><li>中断控制方式，中断处理由 CPU 控制；
DMA 控制方式，DMA 控制器完成。</li></ol><p><strong>通道控制方式</strong>（弱鸡版 CPU）</p><p>以内存为中心，实现设备与内存直接交换数据的控制方式。</p><p>过程：</p><ol><li>CPU发出 I/O 命令，一致性说明所有信息，交给通道。</li><li>一个通道可以控制多个设备，会自行执行全部 I/O 指令，完成后发出中断信号。</li><li>CPU 切换回来执行下一个指令周期。</li></ol><p>要点：通道是一个简化版 CPU。专门完成 I/O 任务，与 CPU 共享内存。</p><p>数据流向：I/O设备 ↔️ 内存</p><ul><li>优：<ol><li>CPU、通道、I/O 设备 均可以并行工作，利用率最高。</li><li>一条指令，可传输一组数据块，数据可离散。</li></ol></li><li>缺：通道实现需要硬件支持，更复杂。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题io-软件的层次结构">问题：I/O 软件的层次结构<a class="hash-link" href="#问题io-软件的层次结构" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="截屏2022-08-14 14.45.38" src="/assets/images/截屏2022-08-14 14.45.38-2f961865bf3c205fb2dfeae18359c3db.png" width="1068" height="510" class="img_E7b_"></p><ol><li><p>用户层软件</p><ul><li><p>提供：操作系统与用户交互接口。把用户请求翻译为格式化I/O请求。SPOOLing</p></li><li><p>服务：I/O操作相关的库函数。</p></li></ul></li><li><p>设备独立性软件</p><ul><li><p>提供：</p><ol><li><p>向用户提供同一的调用接口。</p></li><li><p>设备：保护/分配/回收 (读取权限 / I/O磁盘调度)。映射对应驱动程序。</p></li><li><p>数据：差错处理、缓冲区管理。</p></li><li><p>转换：逻辑 / 物理设备名称映射</p></li></ol></li><li><p>服务：系统调用功能。 </p></li><li><p>要点：与硬件无关的、对设备和数据管理的操作。</p></li></ul></li><li><p>设备驱动程序</p></li></ol><ul><li><p>提供：</p><ol><li><p>每一类设备配置一个驱动程序。</p></li><li><p>逻辑设备表(LUT)，物理设备与驱动程序地址的映射。</p></li><li><p>将上次指令转化为特定硬件的具体 (听得懂) 的指令。</p></li></ol></li><li><p>要点：与硬件相关的，涉及到具体硬件的操作。</p></li></ul><ol start="4"><li><p>中断处理程序</p><ul><li>提供：<ol><li>控制 I/O 设备、内存、CPU 之间数据传输的方式。</li><li>当 I/O 操作完成，发出中断信号，CPU 收到反馈，执行下一周期的指令。</li></ol></li></ul></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题假脱机技术spooling">问题：假脱机技术(SPOOLing)<a class="hash-link" href="#问题假脱机技术spooling" title="标题的直接链接">​</a></h3><p>假脱机技术：SPOOLing 技术。独占设备在系统中数量有限。有些进程可能长期持有独占设备但可能不经常使用设备，而导致设备利用率低。<strong>通过共享设备来虚拟独占设备</strong>，提高了设备利用率。</p><p><strong>脱机技术</strong></p><ul><li><p>脱机：脱离主机控制，进行输入/输出操作。</p></li><li><p>外围控制机 + 高速设备(磁盘)：读取速度比纸带机快。</p></li></ul><p>早期系统中，缓解设备与 CPU 处理速度的矛盾。实现 CPU 与设备并行。纸带打印的速度非常慢，严重拖累了 CPU 的运行效率，所以引入了外围控制机和磁带。CPU 只对磁带进行 I/O 操作，提升了速度。外围控制机负责把磁带的数据写入到纸带上。这样 CPU 得到解脱。</p><p><img loading="lazy" alt="截屏2022-08-14 15.19.00" src="/assets/images/截屏2022-08-14 15.19.00-b30a72e8efb7a10cc2608ce59b33b1f0.png" width="1908" height="658" class="img_E7b_"></p><p><strong>假脱机技术</strong></p><p>输入 / 输出井：</p><ul><li>是在磁盘上开辟的两个存储区。</li><li>模拟脱机输入 / 输出的磁带，用于收容 I/O 设备输入 / 用户进程输出的数据；</li></ul><p>输入 / 输出缓冲区：</p><ul><li>是在内存中开辟出来的两个缓冲区。</li><li>缓冲区装满后，才执行输入输出。</li></ul><p>输入 / 输出进程：</p><ul><li><p>模拟脱机输入 / 输出时的外围控制机。</p></li><li><p>在输入进程的控制下，<strong>输入缓冲区</strong> 暂存从 <strong>输入设备</strong> 输入的数据，之后再转存到 <strong>输入井</strong> 中；</p></li><li><p>在输出进程的控制下，<strong>输出缓冲区</strong> 暂存从 <strong>输出井</strong> 输入的数据，之后再传送到 <strong>输出设备</strong> 上。</p></li></ul><p>过程：磁盘(输入井/输出井) ↔️ 内存(输入/出 缓冲区) ↔️ 设备(输入/出目的地)</p><p>优点：</p><ol><li><strong>速度匹配技术</strong>。提高 I/O 速度（CPU =&gt; 内存 =&gt; 外存 =&gt; 设备）。</li><li><strong>虚拟设备技术</strong>。设备没有分配给进程。进程得到的是一个存储区 + I/O 申请表。</li><li><strong>提高利用率</strong>。实现了设备虚拟共享的功能，提高设备利用率。</li></ol><p><strong>应用：共享打印机</strong></p><ul><li>打印机是独占类设备，多个进程不可同时操作。</li><li>通过 SPOOLing 技术，把打印机虚拟化，可以让进程交替使用打印机，形成打印队列。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="问题缓冲区的分类与结构">问题：缓冲区的分类与结构<a class="hash-link" href="#问题缓冲区的分类与结构" title="标题的直接链接">​</a></h3><p>缓冲区作用：</p><ul><li><strong>提高 CPU 与 I/O 设备的并行程度。</strong></li><li>缓和 CPU 与 I/O 设备速度不匹配的矛盾。CPU 总是等待 I/O 设备。</li><li>减少 CPU 的中断频率。</li><li>解决数据粒度不匹配。eg 一次I/O，进程一块数据，磁盘一个字符 </li></ul><p><strong>单缓冲</strong>：</p><p>最简单的缓冲形式。当用户进程发出一个 I/O 请求，操作系统在内存中为它分配一个缓存区。CPU 和设备的 I/O 读写都通过缓冲区，设备、CPU对缓冲区是串行的。</p><ul><li>流程： CPU(处理) ⬅️ 进程工作区(内存) ⬅️ 缓冲区(内存) ⬅️ 设备 </li><li>要点：工作区的数据一慢，CPU 可立即处理完。</li><li>处理一块数据平均耗时：<ul><li>max ( CPU处理时间 , 缓冲区冲入时间 ) + 工作区冲入时间</li></ul></li></ul><p><strong>双缓冲</strong>：</p><ul><li><p>改进：在单缓冲基础上，增加一个缓冲区，可交替冲入 / 冲出数据。</p></li><li><p>处理一块数据平均耗时：</p><ul><li>max ( CPU处理时间 + 工作区冲入时间 , 缓冲区冲入时间 )</li></ul><p>两设备通信时，单双缓冲的区别：</p></li><li><p>单缓冲：半双工通信 (单向传输)；</p></li><li><p>双缓冲：全双工通信 (双向传输)</p></li></ul><p><strong>循环缓冲</strong></p><ul><li>n 个大小相等的缓冲区，链接成一个循环队列。</li><li>设置 in 指针，指向下一个空缓冲区；设置 out 指针，指向下一个满缓冲区。</li><li>当用户进程需要数据时，从循环缓冲中取出一个装满数据的缓冲区，提取数据。</li><li>当 I/O 设备写入数据时，向循环缓冲中的空区写入数据。</li></ul><p><strong>缓冲池</strong></p><ul><li>n 个缓冲区</li><li>组成三个队列：空缓冲队列、装满后要输出对队列、装满后要输入对队列</li><li>组成 4 种工作缓冲区<ol><li>收容输入数据的工作缓冲区(hin)；</li><li>提取输入数据的工作缓冲区(sin) </li><li>收容输出数据的工作缓冲区(sout)；</li><li>提取输出数据的工作缓冲区(hout)</li></ol></li></ul><blockquote><ul><li>操作系统：<a href="https://blog.csdn.net/qq_36894974/article/details/115654242" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_36894974/article/details/115654242</a></li></ul></blockquote></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/interview/summary/计算机网络"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">计算机网络</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/interview/summary/HTML&amp;CSS"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">HTML&amp;CSS</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#第一章绪论" class="table-of-contents__link toc-highlight">第一章：绪论</a><ul><li><a href="#问题什么是操作系统" class="table-of-contents__link toc-highlight">问题：什么是操作系统</a></li><li><a href="#问题操作系统的功能和服务" class="table-of-contents__link toc-highlight">问题：操作系统的功能和服务</a></li><li><a href="#问题操作系统的发展--分类" class="table-of-contents__link toc-highlight">问题：操作系统的发展 / 分类</a></li><li><a href="#问题操作系统的运行环境--运行机制" class="table-of-contents__link toc-highlight">问题：操作系统的运行环境 / 运行机制</a></li><li><a href="#问题什么是中断--异常" class="table-of-contents__link toc-highlight">问题：什么是中断 / 异常</a></li><li><a href="#问题什么是系统调用" class="table-of-contents__link toc-highlight">问题：什么是系统调用</a></li></ul></li><li><a href="#第二章进程管理" class="table-of-contents__link toc-highlight">第二章：进程管理</a><ul><li><a href="#问题什么是进程" class="table-of-contents__link toc-highlight">问题：什么是进程</a></li><li><a href="#问题为什么引入进程" class="table-of-contents__link toc-highlight">问题：为什么引入进程</a></li><li><a href="#问题进程的状态与转换" class="table-of-contents__link toc-highlight">问题：进程的状态与转换</a></li><li><a href="#问题-进程的控制进程的通信线程的通信" class="table-of-contents__link toc-highlight">问题：🌟 进程的控制/进程的通信/线程的通信</a><ul><li><a href="#-进程间的通信" class="table-of-contents__link toc-highlight">🌟 进程间的通信</a></li><li><a href="#-线程间的通信" class="table-of-contents__link toc-highlight">🌟 线程间的通信</a></li></ul></li><li><a href="#问题-为什么要引入线程" class="table-of-contents__link toc-highlight">问题：🌟 为什么要引入线程</a></li><li><a href="#问题线程的实现" class="table-of-contents__link toc-highlight">问题：线程的实现</a></li><li><a href="#问题处理器的三级调度" class="table-of-contents__link toc-highlight">问题：处理器的三级调度</a></li><li><a href="#问题-调度算法-7" class="table-of-contents__link toc-highlight">问题：🌟 调度算法 (7)</a></li><li><a href="#问题-进程的同步--互斥" class="table-of-contents__link toc-highlight">问题：🌟 进程的同步 / 互斥</a></li><li><a href="#问题-互斥的实现锁" class="table-of-contents__link toc-highlight">问题：🌟 互斥的实现（锁）</a></li><li><a href="#问题信号量" class="table-of-contents__link toc-highlight">问题：信号量</a></li><li><a href="#死锁饥饿活锁死循环的区别" class="table-of-contents__link toc-highlight">死锁、饥饿、活锁、死循环的区别</a></li><li><a href="#问题什么是死锁" class="table-of-contents__link toc-highlight">问题：什么是死锁</a></li><li><a href="#问题死锁产生的条件" class="table-of-contents__link toc-highlight">问题：死锁产生的条件</a></li><li><a href="#问题死锁的处理" class="table-of-contents__link toc-highlight">问题：死锁的处理</a></li><li><a href="#问题死锁的预防--避免" class="table-of-contents__link toc-highlight">问题：死锁的预防 / 避免</a></li><li><a href="#问题死锁的检测--解除" class="table-of-contents__link toc-highlight">问题：死锁的检测 / 解除</a></li><li><a href="#问题并行--并发的区别" class="table-of-contents__link toc-highlight">问题：并行 / 并发的区别</a></li></ul></li><li><a href="#第三章内存管理" class="table-of-contents__link toc-highlight">第三章：内存管理</a><ul><li><a href="#问题内存管理的功能" class="table-of-contents__link toc-highlight">问题：内存管理的功能</a></li><li><a href="#问题内部碎片--外部碎片" class="table-of-contents__link toc-highlight">问题：内部碎片 / 外部碎片</a></li><li><a href="#问题内存的分配方法" class="table-of-contents__link toc-highlight">问题：内存的分配方法</a></li><li><a href="#问题内存的连续分配-3" class="table-of-contents__link toc-highlight">问题：内存的连续分配 (3)</a></li><li><a href="#问题动态分区分配算法" class="table-of-contents__link toc-highlight">问题：动态分区分配算法</a></li><li><a href="#问题解决内存中的碎片问题" class="table-of-contents__link toc-highlight">问题：解决内存中的碎片问题</a></li><li><a href="#问题-基本分页存储管理" class="table-of-contents__link toc-highlight">问题：🌟 基本分页存储管理</a></li><li><a href="#问题-基本分段存储管理" class="table-of-contents__link toc-highlight">问题：🌟 基本分段存储管理</a></li><li><a href="#问题-基本段页式存储管理" class="table-of-contents__link toc-highlight">问题：🌟 基本段页式存储管理</a></li><li><a href="#问题内存的扩充" class="table-of-contents__link toc-highlight">问题：内存的扩充</a></li><li><a href="#问题虚拟内存技术" class="table-of-contents__link toc-highlight">问题：虚拟内存技术</a></li><li><a href="#问题请求分页存储管理" class="table-of-contents__link toc-highlight">问题：请求分页存储管理</a></li><li><a href="#问题页面置换算法-5" class="table-of-contents__link toc-highlight">问题：页面置换算法 5</a></li></ul></li><li><a href="#第四章文件管理" class="table-of-contents__link toc-highlight">第四章：文件管理</a><ul><li><a href="#问题文件基本知识" class="table-of-contents__link toc-highlight">问题：文件基本知识</a></li><li><a href="#问题文件的打开过程" class="table-of-contents__link toc-highlight">问题：文件的打开过程</a></li><li><a href="#问题文件的逻辑结构" class="table-of-contents__link toc-highlight">问题：文件的逻辑结构</a></li><li><a href="#问题文件的目录结构" class="table-of-contents__link toc-highlight">问题：文件的目录结构</a></li><li><a href="#问题硬链接--软链接" class="table-of-contents__link toc-highlight">问题：硬链接 / 软链接</a></li><li><a href="#问题文件的物理结构" class="table-of-contents__link toc-highlight">问题：文件的物理结构</a></li><li><a href="#问题文件的存储空间管理" class="table-of-contents__link toc-highlight">问题：文件的存储空间管理</a></li><li><a href="#问题文件的保护" class="table-of-contents__link toc-highlight">问题：文件的保护</a></li><li><a href="#问题文件系统层次结构" class="table-of-contents__link toc-highlight">问题：文件系统层次结构</a></li><li><a href="#问题磁盘调度算法" class="table-of-contents__link toc-highlight">问题：磁盘调度算法</a></li><li><a href="#问题提高磁头读取速度的办法" class="table-of-contents__link toc-highlight">问题：提高磁头读取速度的办法</a></li></ul></li><li><a href="#第五章设备管理" class="table-of-contents__link toc-highlight">第五章：设备管理</a><ul><li><a href="#问题设备控制器的功能-4" class="table-of-contents__link toc-highlight">问题：设备控制器的功能 4</a></li><li><a href="#问题io-控制方式-4" class="table-of-contents__link toc-highlight">问题：I/O 控制方式 4</a></li><li><a href="#问题io-软件的层次结构" class="table-of-contents__link toc-highlight">问题：I/O 软件的层次结构</a></li><li><a href="#问题假脱机技术spooling" class="table-of-contents__link toc-highlight">问题：假脱机技术(SPOOLing)</a></li><li><a href="#问题缓冲区的分类与结构" class="table-of-contents__link toc-highlight">问题：缓冲区的分类与结构</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">分享</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/frontEnd/JavaScript">前端</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/code/algorithm">算法笔记</a></li><li class="footer__item"><a class="footer__link-item" href="/project">我的项目</a></li></ul></div><div class="col footer__col"><div class="footer__title">社交媒体</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/about">关于我</a></li><li class="footer__item"><a href="https://github.com/moxyNJ" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://juejin.cn/user/2005151873514024" target="_blank" rel="noopener noreferrer" class="footer__link-item">掘金<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Blog</div><ul class="footer__items"><li class="footer__item"><a href="https://www.ninjee.co" target="_blank" rel="noopener noreferrer" class="footer__link-item">Ninjee 的前端篮子</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright"><p>Copyright © 2022 Ninjee Built with Docusaurus.</p><p><a href="http://beian.miit.gov.cn/">晋ICP备2021017941号-2</a></p></div></div></div></footer></div>
<script src="/assets/js/runtime~main.6ad002de.js"></script>
<script src="/assets/js/main.fe74e720.js"></script>
</body>
</html>