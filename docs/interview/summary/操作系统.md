---
title: 操作系统
sidebar_position: 3
date: 2022-08-12
keywords:
  - 操作系统
---

## 第一章：绪论

### 问题：什么是操作系统

计算机的硬件、软件有一种层次关系。硬件在最底层，上层是操作系统，然后是安装的各种应用程序。操作系统是裸机上的第一层软件，是对硬件功能的首次扩充。

引入操作系统的目的是：

1. **接口。**提供一个计算机用户与计算机硬件系统之间的 **接口**；
2. **控制资源**。有效地 **控制和管理** 计算机系统中的各种软件 / 硬件资源。
3. **工作流程**。合理地组织计算机系统的 **工作流程**，以改善系统性能。



### 问题：操作系统的功能和服务

五大基本功能：处理器管理、存储器管理、设备管理、文件管理、用户接口。

1. **处理器管理**：处理器的分配和运行以 **进程** 为基本单位，对处理器管理就是对 **进程的管理**
   - 进程控制：负责进程的创建、撤销、状态转换
   - 进程同步：对并发执行的进程进行协调；
   - 进程通信：负责完成进程间的信息交换
   - 进程调度：按一定算法进行处理器分配（7）
2. **存储器管理**：对内存进行分配、保护、扩充。
   - 内存分配：按一定策略为每道程序分配内存；
   - 内存保护：保证各程序在自己的区域内运行，而不相互干扰。
   - 内存扩充：借助虚拟存储技术，获得增加内存的效果。
3. 设备管理：对计算机系统内的所有设备进行管理。
   - 设备分配：采用缓冲技术、虚拟技术，使设备与主机并行工作。
   - 设备传输控制：实现物理 I/O，即启动设备、中断处理、结束处理等。
   - 设备独立性：用户程序中的设备与实际使用的物理设备无关。
4. 文件管理：对文件系统的管理：
   - 文件存储空间管理：合理的分配与回收
   - 目录管理：提供科学的数据结构，实现高效检索。
   - 文件操作管理：完成文件的读写操作。
   - 文件保护：解决文件的共享、保密、保护问题。
5. 用户接口
   - 命令接口：提供一组命令供用户控制自己的作业。
   - 程序接口：也称 **系统调用**。用户可在程序中使用这组系统调用命令，向操作系统提出：使用外设、申请分配内存、磁盘文件读写等操作。
   - 图形接口：也就是图形化命令接口。



### 问题：操作系统的发展 / 分类

1. 手工阶段：纸带机。人机速度矛盾。
2. 批处理阶段：
   - 单道批处理（脱机输入输出技术）
     - 缓解人机速度矛盾。资源利用率低没解决。
   - 多道批处理（操作系统雏形）
     - 提高资源利用率（多道程序并发执行）。没有人机交互。
3. 分时操作系统（cpu 运行分时间片，任务轮流上 cpu 处理）
   - 提供人机交互。不能优先处理紧急任务。
4. 实时操作系统：
   - 硬实时系统（严格在规定时间内完成处理）
   - 软实时系统（可偶尔违反时间限定）
     - 解决了优先处理紧急任务问题。
5. 网络操作系统
6. 分布式操作系统
   - 多个分散的处理单元，通过网络连接而成的系统。可以动态的分配任务。



### 问题：操作系统的运行环境 / 运行机制

对处理器的执行状态，分为两种：

- **核心态**：**管态**、**系统态**。操作系统管理程序执行时的状态。具有较高特权，能执行一切指令，能访问所有寄存器、存储区。
- **用户态**：**目态**。用户程序执行时机器的状态，权限较低。用户态程序不能直接调用核心态程序，而是通过执行访问核心态的命令，引起 **中断**，由中断系统转入操作系统内的相应程序。

总结：**用户进程在用户态工作、系统内核在内核态工作。**





特权指令：只能由操作系统内核使用，不允许用户直接使用。如 I/O 指令、设置中断屏蔽指令、清内存指令、存储保护指令、设置时钟指令。



操作系统的内核：内核指令在核心态工作。

- 与硬件紧密的模块：时钟管理、 中断处理、设备驱动
  - 时钟管理：操作系统通过时钟管理，向用户提供标准的系统时间。通过时钟中断的管理，实现进程切换、时间片轮转调度。
  - 中断机制：内核负责保护和恢复中断现场的信息。
- 运行频率较高的程序：进程管理、存储器管理、设备管理。



### 问题：什么是中断 / 异常

中断系统的作用：

1. 让操作系统的内核强行夺回 CPU 控制权；
2. 使 CPU 从用户态变为内核态；



**中断 / 外中断**

来源：中断信号来自 CPU **外部**，与当前指令无关。中断是在用户态触发的。

检查时机：CPU 在执行每个指令的周期末尾，CPU检查是否有外中断信号。

- 时钟中断：时间片到期，需要切换应用进程。将正在执行的应用进程暂停，调用新进程
- I/O 中断：用户进行 I/O 相关操作。正在执行的进程需等待用户输入，因而中断当前操作，等待资源到达。
- 硬件中断：硬件故障引起的中断，比如打印机突然没电
- 程序中断：程序在执行过程中的 **一般中断**。比如上文的 I/O 中断。



**异常 / 内中断**

来源：中断信号来自 CPU 内部，与当先执行的指令相关。

检查时机：CPU 在执行指令时，随时检查是否有异常发生。

- 陷阱 / 陷入 / trap：应用程序故意引发。
- 故障 / fault：进程的条件错误、条件不满足、CPU修复故障后继续。（缺页故障）
- 终止 / abort：致命错误，无法修复，终止进程。（整数除 0、非法使用特权指令）

**通常异常会引起中断，而中断未必是异常引起。**



### 问题：什么是系统调用

系统调用是操作系统对应用程序/程序员提供的接口，API (Application Programming Interface)。

系统调用和中断在用户态发生，在核心态处理。

通过系统调用，可以把程序的请求传给内核，内核在完成相应的处理后，再返回给程序。

- 用户进程在 **用户态**，通过 **陷入** 指令，执行系统调用，让进入操作系统的系统内核。
- 此时操作系统转化为 **内核态**。系统内核执行相应的 **系统调用函数**，然后将处理结果返回给用户进程。
- 此时操作系统再切换为 **用户态**，用户进程拿到结果，程序继续运行。

系统调用的功能有：

- 进程管理、文件操作、设备管理、主存管理、进程通信、信息维护。



## 第二章：进程管理

### 问题：什么是进程

**是系统进行资源分配、运行调度的基本单位。**



通过进程、程序来定义进程：

程序：静态（静止的有序代码）、永久（在外存中存放）、一个程序可以产生多个进程。

进程：动态（在执行中的程序）、暂时（在内存中运行）、一个进程可以调用多个程序。



通过引入进程的原因来定义进程：

- 下一个问题



从进程的 5 特征来定义进程：

1. 动态性。最基本特性，执行的过程是动态可控、可调整的。
2. 并发性。多个进程可同时存在内存中，可同时运行。
3. 独立性。进程是独立运行、资源分配和调度的基本单位。
4. 异步性。各个进程的各自独立、不可预知的速度推进。
5. 结构性。每个进程：PCB + 程序段 + 数据段组成。
   - PCB 进程控制块：唯一标识进程、存储控制信息、资源分配信息等。
   - 程序段：程序的指令代码。
   - 数据段：运行中需要的、产生的数据。



### 问题：为什么引入进程

程序的执行是顺序的，具有 3 个特性：

- 顺序性：处理器的操作严格按照程序的规定顺序执行。完成当前操作才做下一个操作。
- 封闭性：程序一旦开始运行，独占系统的所需资源，这些资源只有本程序才能改变。
- 可再现性：程序执行时的初始条件、执行环境相同，重复执行时，结果一定相同。



当操作系统引入 **并发**：

程序的并发执行：若干程序同时在系统中运行，这些程序的执行在时间上是重叠的，即一个程序的执行尚未结束，另一个程序的执行已经开始。

- 优点：提高系统的处理能力和资源利用率。
  - 可以合理的分配： I/O 资源、网络资源、CPU 处理资源、磁盘读写资源等。



这导致了程序失去了特性：

- **间断性**。程序在并发执行时，相互是制约关系，在资源共享时，程序常间断执行。
- **失去封闭性**。程序在执行时，必然受到其他程序的影响，资源不是独立占据并使用的。
- **不可再现性**。程序并发执行时，失去了封闭性，每次执行环境不同，结果也可能不同。



当操作系统引入 **进程**：

为了使程序在并发时保持封闭性和可再现性，需要对资源共享进行更合理的调配。



### 问题：进程的状态与转换

 5 + 2 种状态：

- 正常流程：创建态 ➡️ 就绪态 ➡️ 运行态 ➡️ 终止态；

- 发生阻塞：阻塞态；

- 两个挂起：阻塞挂起、就绪挂起；



创建态：进程正在创建的状态。创建 PCB，填入信息 ➡️ 分配需要的资源。

就绪态：进程已经获得除 CPU 以外的所有资源，一旦获得 cpu 资源，就可以立即执行。

执行态 / 运行态：进程在 cpu 上执行时的状态。

阻塞态 / 等待态：进程因发生事件而 **暂停**，无法执行的状态。通常在等待资源。

终止态 / 结束态：回收进程的资源 ➡️ 撤销 PCB。正常执行完毕，也有可能异常退出。

挂起：排队的过程。从内存调入外存。进程映像放在外存中。



5 状态模型：

![截屏2022-08-12 18.53.00](images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/%E6%88%AA%E5%B1%8F2022-08-12%2018.53.00.png)

7 状态模型

![截屏2022-08-12 18.51.39](images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/%E6%88%AA%E5%B1%8F2022-08-12%2018.51.39.png)

总结：

**执行态** 可以切换到：

- 阻塞状态：是因为请求并等待事件发生
- 就绪状态：是因为时机片用完、抢占式调度中有优先级任务需要执行。
- 终止状态：进程执行完毕、异常中断，需要销毁。

只有 **就绪态**，可以切换到 **执行态**。



### 问题：进程的控制和通信

#### 进程的控制

概念：实现进程的创建、状态转换。通过 **原语** 实现控制，本质是关 / 开中断实现。

原语的工作：

1. **进程的状态切换。**更新 PCB 信息（修改进程运行状态、保存/恢复进程运行环境）；
2. **进程的阻塞 / 唤醒。**将 PCB 插入合适队列（就绪、阻塞等）；
3. **进程的创建 / 撤销。**分配 / 回收资源（进程是否撤出/放入内存）；

原语的内容：

- 阻塞原语：P原语。进程 **主动调用**，并切换。（运行 ➡️ 阻塞）
- 唤醒原语：V原语。进程被动切换。（阻塞 ➡️ 就绪）



#### 进程间的通信

低级通信方式
- P 原语、V 原语：实现进程的同步、互斥

高级通信方式
1. 共享存储
   - 一个互斥访问的共享存储区。

2. 管道通信
   - 管道为一个共享的、互斥访问的特殊共享文件。
   - 一个管道：半双工通信。两个管道：全双工。
   - 管道中必须全满 / 全空，才可以继续操作（读/写）。

3. 消息传递
   - 消息为单位通信（消息头/消息尾）。通过系统的 ‘发送/接受原语’ 实现。
   - 直接通信方式：直接挂到接收方的消息队列中
   - 间接通信方式（信箱）：通过信箱中间体。
4. socket
   - 它可用于不同机器间的进程通信



### 问题：为什么要引入线程

**区分：线程是 CPU 调度的基本单位、进程是资源分配的基本单位。**



进程的特点：

- 进程是一个用有资源的独立单元
- 进程同时又是一个可以被处理器独立调度和分配的单元。

存在的缺点：

- 操作系统还需要进行：进程创建、撤销、状态切换。进行这些操作时，需要为进程分配资源和回收资源，同时要保存进程现场信息，付出了较大时空开销。

解决思路：

- 在系统中尽量少的创建进程、尽量低频的切换进程。

解决方式：

- 将进程的两个特点切分，让进程只完成第一个任务：资源独立的单元，线程去完成第二个任务：CPU 调度的基本单位。

总结：

引入进程的目的，是让多个程序可以并发执行，以改善资源利用率，提高系统吞吐量。

引入线程的目的，是减少程序并发执行时所付出的时空开销，使操作系统更好的并发性。

- 线程是进程内相对独立的、可调度的执行单元。线程自己基本不拥有资源，只在运行时占用一点资源（程序计时器、寄存器、栈），同一个进程内的资源，线程相互共享。



同一进程内的线程：

1. 内存地址共享。
2. 资源共享。
3. 线程间的通信无需经过操作系统。
4. 线程的切换，不会倒车进程的切换。



### 问题：线程的实现

**用户级线程**：不需要操作系统。进程通过线程库控制线程。

- 优：线程调度不需要用户态 / 内核态切换。速度极快。
- 缺：一个线程阻塞，整个进程等待（时间片是分配给进程的，CPU看不到线程，不知道阻塞，不会切换线程）

**内核级线程**：操作系统实现线程，完成线程的创建和销毁工作。

- 优：一个线程阻塞由于 IO 阻塞时，不影响其他线程运行（时间片是分配给线程的，CPU 可以感知到阻塞，然后主动切换）
- 缺：切换速度慢，依赖内核态。

**两种组合**：用户、内核都可以建立线程，各取优点。

- 一对一：一个用户级线程，映射，一个内核级线程
	- 优：并发度高。线程都可以分配到CPU并发执行。
	- 缺：开销大。操作系统管理线程太多。
- 一对多：多个用户级线程，映射，一个内核级线程
	- 优：开销小。管理高效。
	- 缺：并发度低。若一个线程阻塞，则无法调度其他线程，整个进程阻塞。
- 多对多：开销小，并发度高



### 问题：处理器的三级调度

调度是操作系统的基本功能。CPU 是计算机的首要资源，所以调度设计均围绕如何高效利用 CPU 资源而展开。异构作业从提交到执行，通常要经历多级调度。

- 高级调度（作业）：在队列中挑选一个作业，外存进内存，添加资源 + 创建进程。
  - 无  ==>  创建态  ==>  就绪态
- 中级调度（内存）：队列中，外存进内存，挂起变就绪。
  - 挂起就绪态  ==>  就绪态
  - 挂起阻塞态  ==>  阻塞态
- 低级调度（进程）：队列中，内存进 CPU。
  - 就绪态  ==>  运行态





### 问题：调度算法 (7)

#### 进程调度的时机

- 进程主动放弃
  - 进程执行完毕，终止进程。
  - 进程主动阻塞，等待所缺资源，如 I/O 操作、网络资源。
- 进程被动放弃
  - 时间片用尽。
  - CPU 被抢占，高优先级进程在就绪态。
  - 紧急事件处理，如 I/O中断，杀进程。



抢占式：如果有高优先级进程进入就绪态，就会让正在处理的进程挂起。

非抢占式：不会让正在处理的进程挂起，而是等待执行完成，或主动进入阻塞态时，再执行。



#### 批处理系统 (3)

先来先服务 FCFS（作业调度、进程调度）

- 按照队列的思路，先排队的先执行，没有优先级概念。

  - 优：公开、实现简单。进程不会饥饿。

  - 缺：对长作业有利，短作业不利。短作业周转时间长，等待的时间过多。



短作业优先 SJF（非抢占）（作业调度、进程调度）

- 在挂起就绪的队列中，周期性评估可以最短完成的作业，然后优先让它们执行。

  - 优：平均等待时间、平均周转时间最短。

  - 缺：长作业不利，会饥饿



高响应比优先 HRRN（ only 作业调度）

综合了任务的等待时间和预估运行时间，形成相应比公式。

- 响应比 =（等待时间 + 预估运行时间）/ 预估运行时间  >= 1

- 优：综合优点：综合短作业优先（预估运行时间）、先来先服务（等待时间）
	        避免缺点：防止长作业饥饿（等待时间长，则优先服务）。

- 缺：响应比的计算需要开销。



#### 实时操作系统 (4)

时间片轮转（抢占）（only 进程调度）

所有进程按照先来先服务进入队列，CPU 资源按照时间片划分，到时间后就挂起当前的进程，切换下一个进程进场使用 CPU 资源。

- 优：公平、响应快、适用于分时操作系统。所有进程都不会饥饿。

- 缺：进程切换频率高，状态切换需要开销。不能区分任务的紧急程度。



优先级调度（抢占 / 非抢占）（作业调度、进程调度）

- 根据系统需求，可以对任务进行优先级划分。然后高优任务先执行。

  - 优：区分紧急程度，适用于实施操作系统。灵活调整优先级偏好。

  - 缺：高优先级过多，低优先级的进程就会饥饿。



多级队列调度（非抢占）（进程调度）

- 将等候的进程划分多个队列，每个队列都采用各自的调度算法。



多级反馈队列调度（抢占）（进程调度）

- 多级队列：依然划分多个队列，每个队列优先级从高到低，时间片从小到大。

- 每个队列：队列内统一按照 **先来先服务**。

- 当新进程进入调度时，首先放入第一个队列（高优 + 短时）的队尾，等待执行。如果在划分好的时间片内没有执行完毕，则重新放入第二个队列的队尾。以此类推。最后一个队列无法再往下分，则使用 **时间片轮转调度算法**。

  - 优：公平（先来先服务），新进程快速响应（高响应比优先），短进程快速处理（多作业优先），灵活偏好（优先级）

  - 缺：会饥饿（如果第一个队列没执行完，会一直运行第一个队列的进程）



### 问题：进程的同步 / 互斥

同步和互斥的区别：

- 同步，直接相互制约：有先后次序的需求，不同类型的进程。 

- 互斥，间接相互制约：有争用资源的需求，相同类型的进程。 

**同类进程即为互斥关系、不同类进程即为同步关系。**

- 消费者和生产者就是同步关系、消费者和消费者就是互斥关系。



互斥存在临界资源：

- 临界资源：同时只允许一个进程使用的资源。入打印机、绘图机等。

访问临界资源的过程：

进入区：检查是否可进入，上锁🔒的代码，对即将进入的进程添加访问标记。

临界区：临街段，进程中访问临界资源的代码。

退出区：解锁🔓的代码，对访问结束的进程删除访问标记。

剩余区：其余代码，进程中除上述 3 部分以外的代码。

![临界区互斥-来源参考[3]](images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/1fa1353e587e4fe8ab0967538699492d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



互斥的原则（4）

- 空闲让进：临界区空闲，则允许进程访问。
- 忙则等待：临界区占用，则禁止其他进程访问。
- 有限等待：不会饥饿，有限时间内，一定会进入临界区。
- 让权等待：不满足条件的进程，不会盲等，占用CPU资源。



### 问题：互斥的实现

有 4 + 2 种方式：核心思想就是如何 **加锁**。

**软件方式**
	- 单标志法
		- 公用 turn 标志进程号。谁先进去，谁就修改一下 turn。
	- 缺：进入时只检查，不上锁。退出时给对方解锁，给自己上锁（转交使用权）
	- 不满足：空闲让进。必须进程交替进入。

- 双标志先检查法
	- 数组 flag[ false, false ]。先检查，后上锁🔒。进程只修改自己的标志。
	- 缺：检查和上锁无法一气呵成。
	- 优：解决空闲让进。不需要交替进入
	- 不满足：忙则等待。若同时检查通过，会同时进入。
- 双标志后检查法
	- 数组 flag[  ]。先上锁🔒，后检查。进程只修改自己的标志。
	- 缺：检查和上锁无法一气呵成。
	- 优：解决忙则等待。先上锁确保不会同时进入。
	-  不满足：空闲让进 + 有限等待。同时上锁，都进不去，产生饥饿。
- Peterson 算法（皮特森算法）
	- 算法 1 和 3 的结合。flag[false, false ] = 希望进入；turn = 谦让。
	  - 利用 flag[] 解决资源互斥访问、利用 turn 解决进程饥饿。比如 p0 进程想要读区资源，会把自己位置的 flag[0] 置为 true，然后把 ture = 1 谦让对方先执行。接下来判断：`while(flag[1] && turn = 1)` 就一直等待。直到 p1 的 flag 位置调整为 false，或 turn 指向自己 0。
	    - flag[1] 为真表示 p1 希望访问，turn 为 1 表示 p1 可以访问。
	- 进入区：表明想用 ➡️ 主动谦让 ➡️ 检查（对方是否想进，我是否谦让）
	- 检查：对方想进 且 我主动谦让，则循环等待。 while ( flag[1]=true && turn==1 )
	- 优：综合上面三种方法，解决：空闲让进、忙则等待、有限等待。
	- 缺：不满足让权等待（四个方法都不满足）一直占用 CPU。

**硬件方式**

	- 中断屏蔽法 和 硬件指令法
		- 开/关中断指令，利用 **原语**，确保检查和上锁一气呵成，不被打断。
		- 优：简单、易于实现。
		- 缺：while 一直循环等待，违背让权等待，产生饥饿。



### 问题：信号量

引入信号量：

解决进程互斥，上述提到了 6 种方式。软件方法存在算法复杂、效率不高、违背 **忙则等待** 原则的问题；硬件方法存在违背 **让权等待** 的缺点。

信号量是一种同步机构，一种协调进程间共享资源访问的⽅法。

- 解决了让权等待，忙则等待，不会浪费 CPU 资源。

解决方式：通过原语的 开、关 中断，一气呵成，实现上锁🔒的不可被打断。

```js
// semaphore 信号量 = 资源数量统计 + 等待队列
const s = {
	count: 10, 
	queue: []
}

// P 操作：🔒 + 申请 / 使用资源
const wait = (p) => {
	s.count--;
  if (s.count < 0) {
    block 原语  // 阻塞该进程: 进程挂起到阻塞队列
    s.queue.unshift(p); // 将该 p 进程插入等待队列 s.queue
  }
  // p进程使用资源
}

// V 操作：🔓 + 释放/ 产生资源
const signal = (p) => {
  s.count++;
  if (s.count >= 0) {
   	s.queue.pop(); // 队列中取出最后一个进程p
    weakup 原语 // 将p放入就绪队列，等待执行
  }
}
```



#### 信号量的使用

实现进程同步：先 V 后 P。

- 初始资源值为 0。先生产资源、再消费资源。

举例：P1 中有语句 S1，P2 中有语句 S2。要求 S1 必须在 S2 之前执行。

```js
// 设置信号量初始值
semaphore.count = 0;

function P1() {
	// ...
  S1;
  V(count);
}

function P2() {
  // ...
  P(count)
  S2;
}
```

实现进程互斥：先 P 后 V

- 初始资源值为 1。先执行的进程，优先消费资源，后执行的进程只能等待。

```js
// 设置信号量初始值
semaphore.count = 1;

function P1() {
	// ...
  P(count);
	// P1 的临界代码
  V(count);
}

function P2() {
  // ...
  P(count);
	// P2 的临界代码
  V(count);
}
```



### 问题：什么是死锁

通过 哲学家问题引发的 死锁。

- 5 个哲学家围坐一张桌子。桌子上有 5 根筷子，分别放在每个哲学家之间。哲学家的动作有：思考、进餐两种。进餐时需要同时拿起左右手的两根筷子，思考时需要将左右手的筷子放回原处。
- 这就是并发进程执行时，处理临界问题面临的困局。筷子是临界资源，不能被两个哲学家一起使用，仅此用一个信号量数组来表示筷子。
- 死锁僵局：当 5 个哲学家同时饥饿而各自拿左边的筷子时，会导致 5 根筷子均被占用，当他们要拿右手筷子时，会因没有筷子而无限等待，但是又不愿放弃左手的筷子，这就是所谓 **让权等待** 原则。

解决方式：











## 并行和并发有什么区别？

并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器做到的并发，其实是利用时间片的轮转，例如有两个进程A和B，A运行一个时间片之后，切换到B，B运行一个时间片之后又切换到A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。

并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。





