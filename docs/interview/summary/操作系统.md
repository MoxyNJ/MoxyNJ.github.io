---
title: 操作系统
sidebar_position: 3
date: 2022-08-12
keywords:
  - 操作系统
---

## 第一章：绪论

### 问题：什么是操作系统

计算机的硬件、软件有一种层次关系。硬件在最底层，上层是操作系统，然后是安装的各种应用程序。操作系统是裸机上的第一层软件，是对硬件功能的首次扩充。

引入操作系统的目的是：

1. **接口。**提供一个计算机用户与计算机硬件系统之间的 **接口**；
2. **控制资源**。有效地 **控制和管理** 计算机系统中的各种软件 / 硬件资源。
3. **工作流程**。合理地组织计算机系统的 **工作流程**，以改善系统性能。



### 问题：操作系统的功能和服务

五大基本功能：处理器管理、存储器管理、设备管理、文件管理、用户接口。

1. **处理器管理**：处理器的分配和运行以 **进程** 为基本单位，对处理器管理就是对 **进程的管理**
   - 进程控制：负责进程的创建、撤销、状态转换
   - 进程同步：对并发执行的进程进行协调；
   - 进程通信：负责完成进程间的信息交换
   - 进程调度：按一定算法进行处理器分配（7）
2. **存储器管理**：对内存进行分配、保护、扩充。
   - 内存分配：按一定策略为每道程序分配内存；
   - 内存保护：保证各程序在自己的区域内运行，而不相互干扰。
   - 内存扩充：借助虚拟存储技术，获得增加内存的效果。
3. 设备管理：对计算机系统内的所有设备进行管理。
   - 设备分配：采用缓冲技术、虚拟技术，使设备与主机并行工作。
   - 设备传输控制：实现物理 I/O，即启动设备、中断处理、结束处理等。
   - 设备独立性：用户程序中的设备与实际使用的物理设备无关。
4. 文件管理：对文件系统的管理：
   - 文件存储空间管理：合理的分配与回收
   - 目录管理：提供科学的数据结构，实现高效检索。
   - 文件操作管理：完成文件的读写操作。
   - 文件保护：解决文件的共享、保密、保护问题。
5. 用户接口
   - 命令接口：提供一组命令供用户控制自己的作业。
   - 程序接口：也称 **系统调用**。用户可在程序中使用这组系统调用命令，向操作系统提出：使用外设、申请分配内存、磁盘文件读写等操作。
   - 图形接口：也就是图形化命令接口。



### 问题：操作系统的发展 / 分类

1. 手工阶段：纸带机。人机速度矛盾。
2. 批处理阶段：
   - 单道批处理（脱机输入输出技术）
     - 缓解人机速度矛盾。资源利用率低没解决。
   - 多道批处理（操作系统雏形）
     - 提高资源利用率（多道程序并发执行）。没有人机交互。
3. 分时操作系统（cpu 运行分时间片，任务轮流上 cpu 处理）
   - 提供人机交互。不能优先处理紧急任务。
4. 实时操作系统：
   - 硬实时系统（严格在规定时间内完成处理）
   - 软实时系统（可偶尔违反时间限定）
     - 解决了优先处理紧急任务问题。
5. 网络操作系统
6. 分布式操作系统
   - 多个分散的处理单元，通过网络连接而成的系统。可以动态的分配任务。



### 问题：操作系统的运行环境 / 运行机制

对处理器的执行状态，分为两种：

- **核心态**：**管态**、**系统态**。操作系统管理程序执行时的状态。具有较高特权，能执行一切指令，能访问所有寄存器、存储区。
- **用户态**：**目态**。用户程序执行时机器的状态，权限较低。用户态程序不能直接调用核心态程序，而是通过执行访问核心态的命令，引起 **中断**，由中断系统转入操作系统内的相应程序。

总结：**用户进程在用户态工作、系统内核在内核态工作。**





特权指令：只能由操作系统内核使用，不允许用户直接使用。如 I/O 指令、设置中断屏蔽指令、清内存指令、存储保护指令、设置时钟指令。



操作系统的内核：内核指令在核心态工作。

- 与硬件紧密的模块：时钟管理、 中断处理、设备驱动
  - 时钟管理：操作系统通过时钟管理，向用户提供标准的系统时间。通过时钟中断的管理，实现进程切换、时间片轮转调度。
  - 中断机制：内核负责保护和恢复中断现场的信息。
- 运行频率较高的程序：进程管理、存储器管理、设备管理。



### 问题：什么是中断 / 异常

中断系统的作用：

1. 让操作系统的内核强行夺回 CPU 控制权；
2. 使 CPU 从用户态变为内核态；



**中断 / 外中断**

来源：中断信号来自 CPU **外部**，与当前指令无关。中断是在用户态触发的。

检查时机：CPU 在执行每个指令的周期末尾，CPU检查是否有外中断信号。

- 时钟中断：时间片到期，需要切换应用进程。将正在执行的应用进程暂停，调用新进程
- I/O 中断：用户进行 I/O 相关操作。正在执行的进程需等待用户输入，因而中断当前操作，等待资源到达。
- 硬件中断：硬件故障引起的中断，比如打印机突然没电
- 程序中断：程序在执行过程中的 **一般中断**。比如上文的 I/O 中断。



**异常 / 内中断**

来源：中断信号来自 CPU 内部，与当先执行的指令相关。

检查时机：CPU 在执行指令时，随时检查是否有异常发生。

- 陷阱 / 陷入 / trap：应用程序故意引发。
- 故障 / fault：进程的条件错误、条件不满足、CPU修复故障后继续。（缺页故障）
- 终止 / abort：致命错误，无法修复，终止进程。（整数除 0、非法使用特权指令）

**通常异常会引起中断，而中断未必是异常引起。**



### 问题：什么是系统调用

系统调用是操作系统对应用程序/程序员提供的接口，API (Application Programming Interface)。

系统调用和中断在用户态发生，在核心态处理。

通过系统调用，可以把程序的请求传给内核，内核在完成相应的处理后，再返回给程序。

- 用户进程在 **用户态**，通过 **陷入** 指令，执行系统调用，让进入操作系统的系统内核。
- 此时操作系统转化为 **内核态**。系统内核执行相应的 **系统调用函数**，然后将处理结果返回给用户进程。
- 此时操作系统再切换为 **用户态**，用户进程拿到结果，程序继续运行。

系统调用的功能有：

- 进程管理、文件操作、设备管理、主存管理、进程通信、信息维护。



## 第二章：进程管理

### 问题：什么是进程

**是系统进行资源分配、运行调度的基本单位。**



通过进程、程序来定义进程：

程序：静态（静止的有序代码）、永久（在外存中存放）、一个程序可以产生多个进程。

进程：动态（在执行中的程序）、暂时（在内存中运行）、一个进程可以调用多个程序。



通过引入进程的原因来定义进程：

- 下一个问题



从进程的 5 特征来定义进程：

1. 动态性。最基本特性，执行的过程是动态可控、可调整的。
2. 并发性。多个进程可同时存在内存中，可同时运行。
3. 独立性。进程是独立运行、资源分配和调度的基本单位。
4. 异步性。各个进程的各自独立、不可预知的速度推进。
5. 结构性。每个进程：PCB + 程序段 + 数据段组成。
   - PCB 进程控制块：唯一标识进程、存储控制信息、资源分配信息等。
   - 程序段：程序的指令代码。
   - 数据段：运行中需要的、产生的数据。



### 问题：为什么引入进程

程序的执行是顺序的，具有 3 个特性：

- 顺序性：处理器的操作严格按照程序的规定顺序执行。完成当前操作才做下一个操作。
- 封闭性：程序一旦开始运行，独占系统的所需资源，这些资源只有本程序才能改变。
- 可再现性：程序执行时的初始条件、执行环境相同，重复执行时，结果一定相同。



当操作系统引入 **并发**：

程序的并发执行：若干程序同时在系统中运行，这些程序的执行在时间上是重叠的，即一个程序的执行尚未结束，另一个程序的执行已经开始。

- 优点：提高系统的处理能力和资源利用率。
  - 可以合理的分配： I/O 资源、网络资源、CPU 处理资源、磁盘读写资源等。



这导致了程序失去了特性：

- **间断性**。程序在并发执行时，相互是制约关系，在资源共享时，程序常间断执行。
- **失去封闭性**。程序在执行时，必然受到其他程序的影响，资源不是独立占据并使用的。
- **不可再现性**。程序并发执行时，失去了封闭性，每次执行环境不同，结果也可能不同。



当操作系统引入 **进程**：

为了使程序在并发时保持封闭性和可再现性，需要对资源共享进行更合理的调配。



### 问题：进程的状态与转换

 5 + 2 种状态：

- 正常流程：创建态 ➡️ 就绪态 ➡️ 运行态 ➡️ 终止态；

- 发生阻塞：阻塞态；

- 两个挂起：阻塞挂起、就绪挂起；



创建态：进程正在创建的状态。创建 PCB，填入信息 ➡️ 分配需要的资源。

就绪态：进程已经获得除 CPU 以外的所有资源，一旦获得 cpu 资源，就可以立即执行。

执行态 / 运行态：进程在 cpu 上执行时的状态。

阻塞态 / 等待态：进程因发生事件而 **暂停**，无法执行的状态。通常在等待资源。

终止态 / 结束态：回收进程的资源 ➡️ 撤销 PCB。正常执行完毕，也有可能异常退出。

挂起：排队的过程。从内存调入外存。进程映像放在外存中。



5 状态模型：

![截屏2022-08-12 18.53.00](images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/%E6%88%AA%E5%B1%8F2022-08-12%2018.53.00.png)

7 状态模型

![截屏2022-08-12 18.51.39](images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/%E6%88%AA%E5%B1%8F2022-08-12%2018.51.39.png)

总结：

**执行态** 可以切换到：

- 阻塞状态：是因为请求并等待事件发生
- 就绪状态：是因为时机片用完、抢占式调度中有优先级任务需要执行。
- 终止状态：进程执行完毕、异常中断，需要销毁。

只有 **就绪态**，可以切换到 **执行态**。



### 问题：进程的控制和通信

#### 进程的控制

概念：实现进程的创建、状态转换。通过 **原语** 实现控制，本质是关 / 开中断实现。

原语的工作：

1. **进程的状态切换。**更新 PCB 信息（修改进程运行状态、保存/恢复进程运行环境）；
2. **进程的阻塞 / 唤醒。**将 PCB 插入合适队列（就绪、阻塞等）；
3. **进程的创建 / 撤销。**分配 / 回收资源（进程是否撤出/放入内存）；

原语的内容：

- 阻塞原语：P原语。进程 **主动调用**，并切换。（运行 ➡️ 阻塞）
- 唤醒原语：V原语。进程被动切换。（阻塞 ➡️ 就绪）



#### 进程间的通信

低级通信方式
- P 原语、V 原语：实现进程的同步、互斥

高级通信方式
1. 共享存储
   - 一个互斥访问的共享存储区。

2. 管道通信
   - 管道为一个共享的、互斥访问的特殊共享文件。
   - 一个管道：半双工通信。两个管道：全双工。
   - 管道中必须全满 / 全空，才可以继续操作（读/写）。

3. 消息传递
   - 消息为单位通信（消息头/消息尾）。通过系统的 ‘发送/接受原语’ 实现。
   - 直接通信方式：直接挂到接收方的消息队列中
   - 间接通信方式（信箱）：通过信箱中间体。
4. socket
   - 它可用于不同机器间的进程通信



### 问题：为什么要引入线程

**区分：线程是 CPU 调度的基本单位、进程是资源分配的基本单位。**



进程的特点：

- 进程是一个用有资源的独立单元
- 进程同时又是一个可以被处理器独立调度和分配的单元。

存在的缺点：

- 操作系统还需要进行：进程创建、撤销、状态切换。进行这些操作时，需要为进程分配资源和回收资源，同时要保存进程现场信息，付出了较大时空开销。

解决思路：

- 在系统中尽量少的创建进程、尽量低频的切换进程。

解决方式：

- 将进程的两个特点切分，让进程只完成第一个任务：资源独立的单元，线程去完成第二个任务：CPU 调度的基本单位。

总结：

引入进程的目的，是让多个程序可以并发执行，以改善资源利用率，提高系统吞吐量。

引入线程的目的，是减少程序并发执行时所付出的时空开销，使操作系统更好的并发性。

- 线程是进程内相对独立的、可调度的执行单元。线程自己基本不拥有资源，只在运行时占用一点资源（程序计时器、寄存器、栈），同一个进程内的资源，线程相互共享。



同一进程内的线程：

1. 内存地址共享。
2. 资源共享。
3. 线程间的通信无需经过操作系统。
4. 线程的切换，不会倒车进程的切换。



### 问题：线程的实现

**用户级线程**：不需要操作系统。进程通过线程库控制线程。

- 优：线程调度不需要用户态 / 内核态切换。速度极快。
- 缺：一个线程阻塞，整个进程等待（时间片是分配给进程的，CPU看不到线程，不知道阻塞，不会切换线程）

**内核级线程**：操作系统实现线程，完成线程的创建和销毁工作。

- 优：一个线程阻塞由于 IO 阻塞时，不影响其他线程运行（时间片是分配给线程的，CPU 可以感知到阻塞，然后主动切换）
- 缺：切换速度慢，依赖内核态。

**两种组合**：用户、内核都可以建立线程，各取优点。

- 一对一：一个用户级线程，映射，一个内核级线程
	- 优：并发度高。线程都可以分配到CPU并发执行。
	- 缺：开销大。操作系统管理线程太多。
- 一对多：多个用户级线程，映射，一个内核级线程
	- 优：开销小。管理高效。
	- 缺：并发度低。若一个线程阻塞，则无法调度其他线程，整个进程阻塞。
- 多对多：开销小，并发度高



### 问题：处理器的三级调度

调度是操作系统的基本功能。CPU 是计算机的首要资源，所以调度设计均围绕如何高效利用 CPU 资源而展开。异构作业从提交到执行，通常要经历多级调度。

- 高级调度（作业）：在队列中挑选一个作业，外存进内存，添加资源 + 创建进程。
  - 无  ==>  创建态  ==>  就绪态
- 中级调度（内存）：队列中，外存进内存，挂起变就绪。
  - 挂起就绪态  ==>  就绪态
  - 挂起阻塞态  ==>  阻塞态
- 低级调度（进程）：队列中，内存进 CPU。
  - 就绪态  ==>  运行态



### 问题：调度算法 (7)

#### 进程调度的时机

- 进程主动放弃
  - 进程执行完毕，终止进程。
  - 进程主动阻塞，等待所缺资源，如 I/O 操作、网络资源。
- 进程被动放弃
  - 时间片用尽。
  - CPU 被抢占，高优先级进程在就绪态。
  - 紧急事件处理，如 I/O中断，杀进程。



抢占式：如果有高优先级进程进入就绪态，就会让正在处理的进程挂起。

非抢占式：不会让正在处理的进程挂起，而是等待执行完成，或主动进入阻塞态时，再执行。



#### 批处理系统 (3)

先来先服务 FCFS（作业调度、进程调度）

- 按照队列的思路，先排队的先执行，没有优先级概念。

  - 优：公开、实现简单。进程不会饥饿。

  - 缺：对长作业有利，短作业不利。短作业周转时间长，等待的时间过多。



短作业优先 SJF（非抢占）（作业调度、进程调度）

- 在挂起就绪的队列中，周期性评估可以最短完成的作业，然后优先让它们执行。

  - 优：平均等待时间、平均周转时间最短。

  - 缺：长作业不利，会饥饿



高响应比优先 HRRN（ only 作业调度）

综合了任务的等待时间和预估运行时间，形成相应比公式。

- 响应比 =（等待时间 + 预估运行时间）/ 预估运行时间  >= 1

- 优：综合优点：综合短作业优先（预估运行时间）、先来先服务（等待时间）
	        避免缺点：防止长作业饥饿（等待时间长，则优先服务）。

- 缺：响应比的计算需要开销。



#### 实时操作系统 (4)

时间片轮转（抢占）（only 进程调度）

所有进程按照先来先服务进入队列，CPU 资源按照时间片划分，到时间后就挂起当前的进程，切换下一个进程进场使用 CPU 资源。

- 优：公平、响应快、适用于分时操作系统。所有进程都不会饥饿。

- 缺：进程切换频率高，状态切换需要开销。不能区分任务的紧急程度。



优先级调度（抢占 / 非抢占）（作业调度、进程调度）

- 根据系统需求，可以对任务进行优先级划分。然后高优任务先执行。

  - 优：区分紧急程度，适用于实施操作系统。灵活调整优先级偏好。

  - 缺：高优先级过多，低优先级的进程就会饥饿。



多级队列调度（非抢占）（进程调度）

- 将等候的进程划分多个队列，每个队列都采用各自的调度算法。



多级反馈队列调度（抢占）（进程调度）

- 多级队列：依然划分多个队列，每个队列优先级从高到低，时间片从小到大。

- 每个队列：队列内统一按照 **先来先服务**。

- 当新进程进入调度时，首先放入第一个队列（高优 + 短时）的队尾，等待执行。如果在划分好的时间片内没有执行完毕，则重新放入第二个队列的队尾。以此类推。最后一个队列无法再往下分，则使用 **时间片轮转调度算法**。

  - 优：公平（先来先服务），新进程快速响应（高响应比优先），短进程快速处理（多作业优先），灵活偏好（优先级）

  - 缺：会饥饿（如果第一个队列没执行完，会一直运行第一个队列的进程）



### 问题：进程的同步 / 互斥

同步和互斥的区别：

- 同步，直接相互制约：有先后次序的需求，不同类型的进程。 

- 互斥，间接相互制约：有争用资源的需求，相同类型的进程。 

**同类进程即为互斥关系、不同类进程即为同步关系。**

- 消费者和生产者就是同步关系、消费者和消费者就是互斥关系。



互斥存在临界资源：

- 临界资源：同时只允许一个进程使用的资源。入打印机、绘图机等。

访问临界资源的过程：

进入区：检查是否可进入，上锁🔒的代码，对即将进入的进程添加访问标记。

临界区：临街段，进程中访问临界资源的代码。

退出区：解锁🔓的代码，对访问结束的进程删除访问标记。

剩余区：其余代码，进程中除上述 3 部分以外的代码。

![临界区互斥-来源参考[3]](images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/1fa1353e587e4fe8ab0967538699492d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



互斥的原则（4）

- 空闲让进：临界区空闲，则允许进程访问。
- 忙则等待：临界区占用，则禁止其他进程访问。
- 有限等待：不会饥饿，有限时间内，一定会进入临界区。
- 让权等待：不满足条件的进程，不会盲等，占用CPU资源。



### 问题：互斥的实现

有 4 + 2 种方式：核心思想就是如何 **加锁**。

**软件方式**
	- 单标志法
		- 公用 turn 标志进程号。谁先进去，谁就修改一下 turn。
	- 缺：进入时只检查，不上锁。退出时给对方解锁，给自己上锁（转交使用权）
	- 不满足：空闲让进。必须进程交替进入。

- 双标志先检查法
	- 数组 flag[ false, false ]。先检查，后上锁🔒。进程只修改自己的标志。
	- 缺：检查和上锁无法一气呵成。
	- 优：解决空闲让进。不需要交替进入
	- 不满足：忙则等待。若同时检查通过，会同时进入。
- 双标志后检查法
	- 数组 flag[  ]。先上锁🔒，后检查。进程只修改自己的标志。
	- 缺：检查和上锁无法一气呵成。
	- 优：解决忙则等待。先上锁确保不会同时进入。
	-  不满足：空闲让进 + 有限等待。同时上锁，都进不去，产生饥饿。
- Peterson 算法（皮特森算法）
	- 算法 1 和 3 的结合。flag[false, false ] = 希望进入；turn = 谦让。
	  - 利用 flag[] 解决资源互斥访问、利用 turn 解决进程饥饿。比如 p0 进程想要读区资源，会把自己位置的 flag[0] 置为 true，然后把 ture = 1 谦让对方先执行。接下来判断：`while(flag[1] && turn = 1)` 就一直等待。直到 p1 的 flag 位置调整为 false，或 turn 指向自己 0。
	    - flag[1] 为真表示 p1 希望访问，turn 为 1 表示 p1 可以访问。
	- 进入区：表明想用 ➡️ 主动谦让 ➡️ 检查（对方是否想进，我是否谦让）
	- 检查：对方想进 且 我主动谦让，则循环等待。 while ( flag[1]=true && turn==1 )
	- 优：综合上面三种方法，解决：空闲让进、忙则等待、有限等待。
	- 缺：不满足让权等待（四个方法都不满足）一直占用 CPU。

**硬件方式**

	- 中断屏蔽法 和 硬件指令法
		- 开/关中断指令，利用 **原语**，确保检查和上锁一气呵成，不被打断。
		- 优：简单、易于实现。
		- 缺：while 一直循环等待，违背让权等待，产生饥饿。



### 问题：信号量

引入信号量：

解决进程互斥，上述提到了 6 种方式。软件方法存在算法复杂、效率不高、违背 **忙则等待** 原则的问题；硬件方法存在违背 **让权等待** 的缺点。

信号量是一种同步机构，一种协调进程间共享资源访问的⽅法。

- 解决了让权等待，忙则等待，不会浪费 CPU 资源。

解决方式：通过原语的 开、关 中断，一气呵成，实现上锁🔒的不可被打断。

```js
// semaphore 信号量 = 资源数量统计 + 等待队列
const s = {
	count: 10, 
	queue: []
}

// P 操作：🔒 + 申请 / 使用资源
const wait = (p) => {
	s.count--;
  if (s.count < 0) {
    block 原语  // 阻塞该进程: 进程挂起到阻塞队列
    s.queue.unshift(p); // 将该 p 进程插入等待队列 s.queue
  }
  // p进程使用资源
}

// V 操作：🔓 + 释放/ 产生资源
const signal = (p) => {
  s.count++;
  if (s.count >= 0) {
   	s.queue.pop(); // 队列中取出最后一个进程p
    weakup 原语 // 将p放入就绪队列，等待执行
  }
}
```



#### 信号量的使用

实现进程同步：先 V 后 P。

- 初始资源值为 0。先生产资源、再消费资源。

举例：P1 中有语句 S1，P2 中有语句 S2。要求 S1 必须在 S2 之前执行。

```js
// 设置信号量初始值
semaphore.count = 0;

function P1() {
	// ...
  S1;
  V(count);
}

function P2() {
  // ...
  P(count)
  S2;
}
```

实现进程互斥：先 P 后 V

- 初始资源值为 1。先执行的进程，优先消费资源，后执行的进程只能等待。

```js
// 设置信号量初始值
semaphore.count = 1;

function P1() {
	// ...
  P(count);
	// P1 的临界代码
  V(count);
}

function P2() {
  // ...
  P(count);
	// P2 的临界代码
  V(count);
}
```



### 死锁、饥饿、活锁、死循环的区别

- 死锁：(**争用公共资源**) 多个进程之间，相互竞争资源，陷入无期限地等待其他进程占有的资源，都在阻塞等待。
- 饥饿：(**优先级问题**) 某一个进程，因任务调度问题，长期得不到资源而阻塞。(短作业优先) 如果长期无法执行，该进程则处在 **饿死** 状态。
- 活锁：在忙时等待条件下发生的饥饿，称之为“活锁”。例如不公平的互斥算法，让某些进程一直在等待被占用的资源，这实际上也是优先级的问题。
- 死循环：某一个进程，在 while、for 等逻辑内，跳不出循环。(P V 操作)



#### 死锁 / 饿死的区别

共同点：死锁 / 饿死都是因 **竞争资源** 而引起的。

不同点：

从所争资源考虑：

- 死锁：死锁进程等待的是永远也不会释放的资源。
- 饿死：饿死进程等待的是会释放、但永远也不会分配给自己的资源。

从进程状态考虑：

- 死锁：一定发生了循环等待 (哲学家困境)，可以通过资源分配图检测出。
- 饿死：没有循环等待，无法通过资源分配图检测。

从涉事人员考虑：

- 死锁：一定是两个以上的进程，都发生了死锁。
- 饿死：一个进程就可能被饿死。



### 问题：什么是死锁

通过 **哲学家问题** 引发的死锁。

- 5 个哲学家围坐一张桌子。桌子上有 5 根筷子，分别放在每个哲学家之间。哲学家的动作有：思考、进餐两种。进餐时需要同时拿起左右手的两根筷子，思考时需要将左右手的筷子放回原处。
- 这就是并发进程执行时，处理临界问题面临的困局。筷子是临界资源，不能被两个哲学家一起使用，仅此用一个信号量数组来表示筷子。
- 死锁僵局：当 5 个哲学家同时饥饿而各自拿左边的筷子时，会导致 5 根筷子均被占用，当他们要拿右手筷子时，会因没有筷子而无限等待，但是又不愿放弃左手的筷子，这就是所谓 **让权等待** 原则。

解决方式：规定奇数号的哲学家先拿左边筷子，然后拿右边筷子；偶数号的哲学家相反。



定义：当多个进程因竞争系统资源或相互通信，而处于永久阻塞状态。若无外力作用，僵局无法打破，这些进程都会陷入无期限地等待其他进程占有的、自己无法得到的资源。



### 问题：死锁产生的条件

围绕资源，死锁产生的原因有两点：**系统资源不足** (根本原因)、**进程推进顺序不当**。

**死锁产生必须满足 4 个条件**：

- **互斥条件**：进程间的资源必须互斥。一段时间内某种资源仅为一个进程所占有。
- **不剥夺条件**：进程掌握的资源无法强制剥夺收回，只能由进程使用完后，主动释放。
- **请求和保持条件**： 进程已经申请到一部分资源，在等待分配其他需求资源的同时，继续占有已经分配到的资源，不释放。
- **环路等待条件**：进程间发生了循环等待链条，也就是哲学家困境。需要的资源被其他进程持有，这样形成了一个资源的循环等待链。



### 问题：死锁的处理

主要有 4 种思路：

- 不处理：鸵鸟算法。
- 预防死锁：静态处理，预先破坏产生死锁的 4 条件中的某些条件。
- 避免死锁：动态处理，在分配资源过程中，用算法（银行家算法），防止发生死锁。
- 死锁的检测和解除：发生死锁后解决。通过系统检测，及时发现死锁，然后解决。



### 问题：死锁的预防 / 避免

**预防死锁** 和 **避免死锁** 是不一样的：

- 两种都在死锁产生之前，实施措施，不同的是：
- **死锁预防** 是非常严格的，通常会对系统并发性造成很大副作用，同时也不需要再添加额外的算法去避免死锁。
- **死锁避免** 对系统附加条件相关宽松，有利于并发，但在资源被分配出去之前要计算分配之后系统是否安全，有额外的算法开销。



#### 死锁的预防

只需破坏产生死锁的 4 个必要条件之一即可：

- 破坏互斥：
  - 让资源不再互斥：临界资源改为共享资源（SPOOLing技术）
  - 缺点：有些资源（🖨️）无法变为共享资源，可行性低。
- 破坏不可剥夺：
  - 当进程已经获得一部分资源，而剩余资源无法满足时，有两种思路：
    1. 强制释放自己的所有资源；
    2. 按照优先级，剥夺别人的资源（优先级）。
  - 缺：算法开销大，有些进程会饥饿，被随意剥夺资源可能会造成严重后果。
- 破坏请求和保持：
  - 静态分配的办法，进程一次性申请全部所需资源，预先分配好全部资源，才运行
  - 缺：资源利用率低，有些进程迟迟得不到资源，会饥饿。
- 破坏循环等待：
  - 有序资源分配。资源按不同类型编号；进程申请资源必须从小到大，有序申请。
  - 比如给打印机为1，磁带机为2，进程必须从1到2申请，不能反着申请。
  - 缺：不便于新增设备，资源利用率低，编程困难。



#### 死锁的避免

动态方法：在系统进行资源分配前，先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则分配，否则不分配，进程继续等待。

- 安全状态：系统不会死锁，则该序列为安全序列。
- 不安全状态：系统不稳定，有可能会死锁，也有可能会回到安全状态。
- 安全性算法：寻找安全序列 —— 银行家算法 🏦



#### 银行家算法

> [🔗](https://www.bilibili.com/video/BV1Nx411X7hT?spm_id_from=333.337.search-card.all.click&vd_source=591709e27d352a97b88a4c9ec8b2ad39)

通过多个进程资源分配表：

| 进程最大需求量 | 已经分配量 | 还需要的量 | 系统剩余资源 | 申请的量 |
| -------------- | ---------- | ---------- | ------------ | -------- |
| max            | Allocation | Need       | Available    | Reques   |

步骤：
	1. 检查申请是否超过这个进程之前申请的最大需求量；
	1. 检查系统剩余可用资源是否满足；
	1. 模拟分配，使用安全性算法，寻找安全序列（就是资源先给谁，后给谁）



### 问题：死锁的检测 / 解除

#### 死锁的检测

数据结构：资源分配图 (有向图)

- 两种结点：进程结点(一个进程)、资源结点(一类资源，有数量)
- 两种边：申请边、分配边

检测方式：

1. 找到可能形成孤立的、 不阻塞的进程结点，即它已经获得了所有所需资源，可以继续运行知道进程执行完毕，然后释放持有资源。
2. 假设该可能孤立的进程释放资源后，消除其持有资源的边，简化资源分配图。
3. 重复这一过程，直到不可再简化：
   - 若能消除所有边 ➡️ 可完全简化的，没有死锁
   - 不能消除所有边 ➡️ 发生死锁



#### 死锁的解除

资源剥夺法：从其他进程中抢占所需资源，挂起这些进程，让自己解除死锁状态。

撤销进程法：终止某些进程，让它们归还占用资源，然后分配给其他进程，解除死锁状态。

进程回退法：让一些进程回退到系统不死锁的状态，进程自愿释放资源，而不是剥夺。这要求系统保持进程的历史信息，设置还原点。



### 问题：并行 / 并发的区别

并发：一条赛道，同步执行。并发是单核 CPU 的一种调度算法。通过时间片轮转，给不同的进程都有公平参与执行的机会，不会导致进程饿死。因切换速度足够快，宏观上看似多个进程在同时执行。

并行：多条赛道，同时执行。就是多核 CPU，可以各自管理，真正的同时执行多个进程。



## 第三章：内存管理

### 问题：内存管理的功能

1. 内存空间分配 / 回收：连续 / 非连续 分配。
2. 扩充内存：对内存空间的扩充，采用 覆盖、交换、虚拟 等方式。
3. 地址变换：相互转换：程序中使用的逻辑地址，和内存中实际的物理地址
4. 内存保护：(两种寄存器) 保证不同作业互不干扰，防止作业 A 发生错误而破坏作业 B



### 问题：内存的扩充

**覆盖技术** (早期操作系统)

1. 一个大程序划分为若干‘覆盖’ = 程序段
2. 内存中：一个固定区 (主程序)。不会掉入调出。存放最活跃的程序段。
3. 内存中：若干覆盖区。互斥的 ‘覆盖’，可共享一个覆盖区，运行时动态掉入调出。

- 缺点：程序员需要声明覆盖结构，不透明，增加编程负担。

**交换技术** (内存调度)

- 当缺页率频发、内存不足时，执行交换技术。

1. 内存中：调出某些进程放到外存，保留PCB，移至挂起态。
2. 外存中：设置文件区、对换区 (交换区)。对换区读取速度快，且有就绪挂起、阻塞挂起队列。

**虚拟技术**（后面一大节）



### 问题：内部碎片 / 外部碎片

内部碎片：已经分配给作业，但不能被作业利用的内存空间。

外部碎片：还没有分配给作业，但由于碎片太小而无法分配给作业的内存空间。

通俗说，作业占用的内存空间，没有装满，有剩余就是内部碎片。有些内存区域无法分配给作业，就是外部碎片。



### 问题：内存的分配

内存的空间分类 / 回收，分为 2 个思路：

- **连续分配** 3 ：单一连续、固定分区、动态分区
- **非连续分配** 3：(可连续、可离散) 基本分页存储管理、段页式存储管理、



### 问题：内存的连续分配 (3)

**单一连续分配** (单道程序)

最简单的分配方式，系统区是内存低地址部分，给系统使用。

- 内存分为：系统区 + 用户区。
- 只支持一个程序进入，静态分配，采用覆盖技术扩充内存。
- 优：管理简单，无外部碎片。
- 缺：单用户、单操作系统，有内部碎片。



**固定分区分配** (多道程序)

内存事先划分大小不等的固定区域，在运行时不能更改。每个分区可以装入一道程序。

- 内存划分：系统区 + 大小不一 (相等) 的固定分区，不再更改。
- 设置分区说明表：分区号(隐含)、容量、起始地址、状态(是否分配)。
- 程序装入时：找到合适大小的分区装入，不满足则拒绝装入，装入采用静态重定位方式
- 优：支持多道程序，无外部碎片。
- 缺：有内部碎片，分区固定灵活度不高，利用率低，无法多进程共享一个内存区。



**动态分区分配** (多道程序) / **可变式分区分配**

- 内存划分：系统区 + 用户区。不预先划分，进程要多大，划分多大。

- 一表一链：‘空闲分区表’ + ‘空闲分区链’ ：分区号、容量、起始地址、状态。将空闲的区域通过链表形式串联起来。

- 采用动态分区分配算法 (4)：(下文) 首次、最佳、最差、邻近

- 内存回收：内收内村后，会更新链、表信息。合并问题连续的内存空间。

	- 优：无内部碎片，灵活度，利用率高
	
	- 缺：有外部碎片，可以用紧凑技术解决。动态算法有开销。当有大作业来到时，其存储空间的申请可能会得不到满足。



### 问题：动态分区分配算法

**首次适应算法**：（First Fit，FF）—— **最佳**

把空间分区按照地址递增的次序用链表串联。进程分配内存时顺序查链表，找到第一个符合的，空间足够大的分区进行分配。把该分区划分出和进程所需空间相等的内存，剩余内存用链表继续串联。

- 优：综合性能最佳，算法开销小，不需要重排列分区。

- 缺：在低地址区，小碎片 (外部碎片) 会越来越多，从低地址查表，浪费开销。



**邻近适应算法**：（Next Fit，NF）

在首次适应算法的基础上，把队列改成循环队列。这样不用每次从队首开始查找，而是从上次查找分区位置开始查找。

- 优：不需要每次从低地址小分区开始查找，提升速度、算法开销小。

- 缺：高地址的大分区可能储备不足，大进程得不到满足。



**最佳适应算法**：（Best Fit，BF）

链表按照容量递增顺序组织。从小到大查表，优先用最小的。

- 优：保留许多大分区满足大进程需求

- 缺：产生许多难以利用的小碎片 (外部碎片)，算法开销大，需要频繁重排列链表。




**最差适应算法**：（Worst Fit，WF）

链表容量递减顺序。从大到小查表，优先用最大的。

- 优：减少小碎片的产生

- 缺：大分区不足，大进程得不到满足，算法开销大，频繁重排列链表。




### 问题：解决内存中的碎片问题

**拼接 / 紧凑 / 紧缩技术**：已分配分区移动到内存一端，让碎片可以合并。

拼接时机：

1. 出现分区回收时，就拼接（过于频繁）。
2. 有作业找不到合适空间 + 内存碎片容量足够时，拼接。 
   - 缺点：系统开销大



### 问题：内存的非连续分配









