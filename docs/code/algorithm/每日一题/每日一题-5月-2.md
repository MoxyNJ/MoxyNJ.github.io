---

title: 5月 下
date: 2022-05-15
tags: [algorithm, everyday]

---


## 0501｜[面试题 04.06. 后继者](https://leetcode.cn/problems/successor-lcci/)

#### 方法一：中序遍历

思路：当在 while 中遍历每一个节点时，

1. 如果找到了节点 p，那把 flag 的值从默认的 false 设置为 true；
2. 在遍历每个节点时判断：如果 flag 为 true，证明已经找到了节点 p，此时当前节点 point 就是要找的 p 的后继节点，直接返回。

```js
var inorderSuccessor = function (root, p) {
  if (!root) return null;

  let flag = false;
  const stack = [];  // stack.push(point.left)
  let point = root;

  while (stack.length || point) {
    if (point !== null) {
      stack.push(point);     // 遍历左子树
      point = point.left;
    } else {
      point = stack.pop()
      if (point.val === p.val) flag = true;  // 找到 p 节点，调整 flag
      else if (flag) return point; 	// 如果 flag 为 true，返回 point
      point = point.right
    }
  }
  return null;
};
```

#### 方法二：利用二叉搜索树的特性

二叉搜索树的中序遍历，结果是递增的，这就意味着当找到节点 p 后，后继节点是 ` p.val` 值大的所有集合中，最小的值。

它的后继节点只有两种情况：

- p.right 存在，那么后继节点就在右子树中的最左下角。
- p.right 不存在，那么此时中序遍历回回溯到父节点，也就是进入 p.val 这左子树的父节点。

```js
var inorderSuccessor = function (root, p) {
  let parent = null, node = root
  while (node != null) {
    // node 大于 p 节点，往左子树递归
    if (node.val > p.val) {
      [parent, node] = [node, node.left];
      // node 小于 p 节点，往右子树递归
    } else {
      node = node.right;
    }
  }
  return parent
};
```

