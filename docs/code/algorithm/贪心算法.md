---
title: 8. 贪心算法
sidebar_position: 8
date: 2022-06-01
tags: [algorithm]
---

## 什么是贪心算法

> 代码随想录
>
> - **贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。
> - 刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。
>
> - 面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了。



## 455. 分发饼干

- [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)
- 0601，easy，quick
- 贪心

只需要对 🍪 g，和 🧒 s 进行 sort，然后确保每个饼干 `s[j]` 是大于小孩 `g[i]`的，且是最小值。

![20201123161809624](images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20201123161809624.png)

```js
var findContentChildren = function (g, s) {
  s.sort((x, y) => x - y);
  g.sort((x, y) => x - y);

  // 饼干 s[j] 是大于 g[i] 的最小值
  let i = 0, j = 0;
  while (s[j] && g[i]) {
    while (s[j] && s[j] < g[i]) j++;
    if (!s[j]) break;
    i++, j++;
  }
  return i;
};
```



- [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)
- 0602，mid，answer
- 贪心，动态规划

##### 方法一：贪心

对这种问题，自己能画出一个图清晰的图，可以快速的找到解题思路。

下图可以看到，当出现相等、连续递增、连续递减的情况时，我们跳过中间数，去判断下一个数即可。

复杂度：时间（*O(n)*），空间（*O(1)*）。

![20201124174327597](images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20201124174327597.png)

- preDiff 统计上一个可参考的差值；
- curDiff 统计当前的差值，只有当前差值和上一个差值不相同时，结果 count 才 +1；否则就跳过，进行判断下一个数字。
- 因为至少长度为 2 以上，才可以有差值的记录，所以 index 从 1 开始、count 最小值为 1。

```js
var wiggleMaxLength = function (nums) {
  if (nums.length === 1) return 1; // 特例
  let preDiff = 0; // 只有在初始化时，preDiff = 0，除此之外一定是大于/小于0的
  let count = 1;

  for (let index = 1; index < nums.length; index++) {
    // 当前差值
    const curDiff = nums[index] - nums[index - 1];
    // 如果没有差值为0、出现递增 / 递减序列，则跳过。
    if (curDiff > 0 && preDiff <= 0 || curDiff < 0 && preDiff >= 0) {
      count++;
      preDiff = curDiff;
    }
  }
  return count;
};
```

#### 方法二：动态规划

可以发现，对于我们当前考虑的这个数，要么是作为山峰（即nums[i] > nums[i-1]），要么是作为山谷（即nums[i] < nums[i - 1]）：

- 时间复杂度：*O(n)*， 空间复杂度：*O(1)*

如果一切顺利，没有连续相等、连续递增、连续递减的情况：

- 如果当前是山峰，当前山峰的最长序列值就是山谷 + 1： `up = down + 1`；
- 如果当前是山谷，当前山谷的最长序列值就是山峰 + 1： `down = up + 1`；

但如果发生不顺的时候，及产生了连续相等、连续递增、连续递减的情况：

- 山谷 down 和山峰  up 的值就不发生改变。
- 比如当前是山峰，`up = Math.max( down + 1, up)`，因为在连续递增的最初，up 已经被赋值为 `down + 1`，此时后续发生连续递增 / 连续相等，up 的值就不会再增加了，而是一直维持 `down + 1` 不变。

```js
var wiggleMaxLength = function (nums) {
  if (nums.length === 1) return 1;

  let down = 1; // 考虑前i个数，当第i个值作为峰谷时的情况（则第i-1是峰顶）
  let up = 1;   // 考虑前i个数，当第i个值作为峰顶时的情况（则第i-1是峰谷）

  for (let i = 1; i < nums.length; i++) {
    // 当前是峰谷：如果之前经历过连续递减 / 连续相等，这里就会用 down 值；
    if (nums[i - 1] > nums[i])
      down = Math.max(up + 1, down);

    // 当前是峰顶：如果之前经历过连续递增 / 连续相等，这里就会用 up 值；
    if (nums[i - 1] < nums[i])
      up = Math.max(down + 1, up)

    // console.log(Math.max(nums[i] - nums[i - 1]), down, up);
  }
  return Math.max(down, up);
};
```

